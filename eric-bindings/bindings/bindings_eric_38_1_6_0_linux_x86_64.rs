/* automatically generated by rust-bindgen 0.69.4 */

pub const PLATFORM_NAME: &[u8; 13] = b"Linux/x86-64\0";
pub const LINUX: u32 = 1;
pub const ERIC_UINT32_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ERIC_STDINT_VORHANDEN: u32 = 1;
pub const HAS_FUTIME: u32 = 0;
pub const UTIME_NEEDS_CLOSED_FILE: u32 = 1;
pub const _UTIME_H: u32 = 1;
pub const ERIC_MAX_LAENGE_FUSSTEXT: u32 = 30;
pub const ERIC_TESTMERKER_CLEARINGSTELLE: &[u8; 10] = b"700000004\0";
pub const ERIC_TESTMERKER_ECC: &[u8; 10] = b"700000001\0";
pub type BYTE = ::std::os::raw::c_uchar;
pub type byte = ::std::os::raw::c_uchar;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    pub actime: __time_t,
    pub modtime: __time_t,
}
#[test]
fn bindgen_test_layout_utimbuf() {
    const UNINIT: ::std::mem::MaybeUninit<utimbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<utimbuf>(),
        16usize,
        concat!("Size of: ", stringify!(utimbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<utimbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(utimbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(actime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(modtime)
        )
    );
}
extern "C" {
    pub fn utime(
        __file: *const ::std::os::raw::c_char,
        __file_times: *const utimbuf,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EricInstanz {
    _unused: [u8; 0],
}
#[doc = " @brief Handle auf eine ERiC-Instanz.\n\n ERiC-Instanzen werden von der Multithreading-API angelegt,\n verwendet und wieder freigegeben, siehe ericmtapi.h.\n \\n Alle API-Funktionen der Multithreading-API nehmen einen Zeiger auf eine\n ERiC-Instanz entgegen und verrichten ihre Aufgaben auf dieser ERiC-Instanz.\n Die EricInstanz enthlt smtliche vernderlichen Zustnde des ERiC.\n Dies sind ERiC-Einstellungen, Plugin- und Log-Verzeichnis, Proxyeinstellungen,\n Zertifikatshandle, Rckgabepuffer, etc.\n \\n Es knnen mehrere ERiC-Instanzen parallel angelegt werden. Jede dieser\n ERiC-Instanzen ist unabhngig von allen anderen ERiC-Instanzen. Verfgen\n mehrere Threads jeweils ber ihre eigene ERiC-Instanz, knnen sie diese\n parallel verwenden. Dazu mssen die Threads den API-Funktionen der\n Multithreading-API ihre jeweils eigene ERiC-Instanz bergeben.\n \\n ERiC-Instanzen sollen nicht fr jede Aufgabe neu erstellt und konfiguriert\n werden. Das Erstellen und Zerstren einer ERiC-Instanz ist ressourcen- und zeitintensiv.\n Die Lebenszeit einer ERiC-Instanz sollte beispielsweise eher der Lebenszeit\n eines Arbeiter-Threads in einem Pool entsprechen, als der Verarbeitungsdauer\n einer einzelnen Aufgabe an einen Arbeiter-Thread.\n \\n ERiC-Instanzen knnen zwischen Threads ausgetauscht werden. Eine\n ERiC-Instanz darf aber nicht in zwei Threads gleichzeitig verwendet werden.\n\n @see\n       - ::EricMtInstanzErzeugen()\n       - ::EricMtInstanzFreigeben()"]
pub type EricInstanzHandle = *mut EricInstanz;
#[doc = " @brief Der Datentyp byteChar wird immer dann verwendet, wenn an diesem Parameter\n        keine UTF-8 codierte Daten erwartet werden.\n        Diese Daten werden ungeprft verwendet.\n        <b>Zum Beispiel:</b> Pfade"]
pub type byteChar = ::std::os::raw::c_char;
#[doc = " @brief Integer-Typ fr Zertifikat-Handles."]
pub type EricZertifikatHandle = u32;
#[doc = " @brief Das ::EricTransferHandle wird beim Anwendungsfall \"Datenabholung\"\n        der API-Funktion ::EricBearbeiteVorgang() bergeben.\n\n Es ist vom Aufrufer zu initialisieren\n und wird ::EricBearbeiteVorgang() als Zeiger bergeben. Es wird\n verwendet, um bei der Datenabholung mehrere Versandvorgnge zu bndeln.\n Dabei ist das Handle fr den ersten Vorgang \"Anfrage\" mit dem Wert 0\n zu intialisieren bevor ::EricBearbeiteVorgang() aufgerufen wird.\n Das von ::EricBearbeiteVorgang() zurckgegebene Handle ist dann\n bei allen Folgevorgngen derselben Datenabholung unverndert\n wieder zu bergeben.\n \\n Wird bei einer Datenabholung NULL oder ein ungltiger Zeiger\n als Handle bergeben, gibt ::EricBearbeiteVorgang()\n den Fehlercode ::ERIC_GLOBAL_TRANSFERHANDLE zurck.\n \\n Bei allen Verfahren auer der Datenabholung sollte das Transferhandle\n beim Aufruf der ::EricBearbeiteVorgang() NULL sein. Wird bei solchen\n Verfahren ein Handle bergeben, so wird dieses ignoriert.\n"]
pub type EricTransferHandle = u32;
#[doc = " @brief Der Datensatz soll validiert werden."]
pub const eric_bearbeitung_flag_t_ERIC_VALIDIERE: eric_bearbeitung_flag_t = 2;
#[doc = " @brief Der Datensatz soll an den ELSTER Annahmeserver versendet werden."]
pub const eric_bearbeitung_flag_t_ERIC_SENDE: eric_bearbeitung_flag_t = 4;
#[doc = " @brief Der Datensatz soll gedruckt werden."]
pub const eric_bearbeitung_flag_t_ERIC_DRUCKE: eric_bearbeitung_flag_t = 32;
#[doc = " @brief Der Datensatz soll auf Hinweise hin geprft werden."]
pub const eric_bearbeitung_flag_t_ERIC_PRUEFE_HINWEISE: eric_bearbeitung_flag_t = 128;
#[doc = " @brief Bearbeitungsflags fr die Anwendungsflle von EricBearbeiteVorgang().\n\n Welche Anwendungsflle von der jeweiligen Datenart untersttzt werden,\n ist dem ERiC-Entwicklerhandbuch.pdf zu entnehmen."]
pub type eric_bearbeitung_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EricReturnBufferApi {
    _unused: [u8; 0],
}
#[doc = " @brief Handle zur Verwaltung und Verwendung von Rckgabepuffern.\n\n Viele ERiC API-Funktionen geben Informationen an ihren Aufrufer zurck,\n indem sie Daten in sogenannte Rckgabepuffer schreiben.\n Solche Rckgabepuffer mssen mit ::EricRueckgabepufferErzeugen() angelegt\n werden. Das bei dieser Erzeugung generierte Puffer-Handle wird vom Aufrufer\n an die API-Funktion bergeben, die den Puffer leert bevor sie dann in den\n Puffer schreibt. Ein einmal generiertes Puffer-Handle kann damit auch fr\n mehrere aufeinanderfolgende Aufrufe von ERiC API-Funktionen wiederverwendet\n werden.\n Mittels ::EricRueckgabepufferLaenge() kann danach die Anzahl der in den\n Puffer geschriebenen Bytes ermittelt werden.\n Mit ::EricRueckgabepufferInhalt() kann der Pufferinhalt abgefragt werden.\n Jeder Rckgabepuffer muss nach seiner Verwendung mit\n ::EricRueckgabepufferFreigeben() wieder freigegeben werden.\n\n Die Struktur EricReturnBufferApi kapselt die Rckgabepuffer-Implementierung.\n Anwender der ERiC API verwenden ausschlielich Zeiger auf Instanzen dieser\n Struktur und mssen daher deren Felder nicht kennen.\n\n Rckgabepuffer sind der Singlethreading-API bzw. einer ERiC-Instanz der\n Multithreading-API fest zugeordnet. Die Funktionen der ERiC API, die einen\n Rckgabepuffer entgegen nehmen, geben den Fehlercode\n ::ERIC_GLOBAL_PUFFER_UNGLEICHER_INSTANZ zurck, wenn der bergebene\n Rckgabepuffer\n      - mit der Singlethreading-API erzeugt worden ist und dann mit der\n        Multithreading-API verwendet wird\n      - mit der Multithreading-API erzeugt worden ist und dann mit der\n        Singlethreading-API verwendet wird\n      - mit einer ERiC-Instanz erzeugt worden ist und dann mit einer\n        anderen Instanz verwendet wird.\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf Kap. \"Rckgabepuffer der ERiC Programmierschnittstelle\"\n      - ::EricRueckgabepufferErzeugen()\n      - ::EricRueckgabepufferLaenge()\n      - ::EricRueckgabepufferInhalt()\n      - ::EricRueckgabepufferFreigeben()"]
pub type EricRueckgabepufferHandle = *mut EricReturnBufferApi;
#[doc = " @brief Diese Struktur enthlt alle fr den Druck notwendigen Informationen.\n\n Der Anwendungsentwickler muss diese Struktur allokieren und nach Verwendung\n wieder freigeben.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_druck_parameter_t {
    #[doc = " @brief Version dieser Struktur. Die Version muss derzeit immer 2 sein.\n        Bei nderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 2 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Soll ein Vorschau-PDF erstellt werden?\n\n - vorschau = 1: Ein Vorschau-PDF wird erzeugt und als solches gekennzeichnet.\n - vorschau = 0: Es wird kein Vorschau-PDF erzeugt.\n\n @note Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub vorschau: u32,
    #[doc = " @brief Soll das PDF nur die erste Seite oder alles enthalten?\n\n - ersteSeite = 1: Es wird nur die erste Seite einer komprimierten Erklrung gedruckt.\n - ersteSeite = 0: Es wird alles gedruckt.\n\n @note\n       - Fachliche Informationen sind im ERiC-Entwicklerhandbuch.pdf nachzulesen.\n       - Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben."]
    pub ersteSeite: u32,
    #[doc = " @brief Soll die PDF-Datei fr einen doppelseitigen Ausdruck mit Heftrand zum Lochen vorbereitet werden?\n\n - duplexDruck = 1: Die geraden Seiten werden fr einen Heftrand zum Lochen nach links eingerckt, Details siehe ERiC-Entwicklerhandbuch.pdf\n - duplexDruck = 0: Es erfolgt keine Einrckung der geraden Seiten. Das erstellte PDF ist nur zum blattweisen Ausdruck der Seiten vorgesehen.\n\n @note Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben."]
    pub duplexDruck: u32,
    #[doc = " @brief Pfad der erzeugten PDF-Datei.\n\n Pfade mssen auf Windows in der fr Dateifunktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 bergeben werden.\n Weiterfhrende Informationen hierzu, sowie zu nicht erlaubten Zeichen in\n Pfaden und Pfadtrennzeichen, relative Pfadangabe, etc. siehe\n Entwicklerhandbuch Kapitel \"bergabe von Pfaden an ERiC API-Funktionen\".\n\n <b>Windows-Beispiel:</b> \"c:\\\\test\\\\ericprint.pdf\"\n\n Soll eine PDF-Datei angelegt werden, ist der pdfName zwingend erforderlich\n\n <B> Besonderheiten bei Sammeldaten </B>\n Fr Sammeldaten wird dem PDF-Dateinamen vor der Dateiendung das Nutzdatenticket\n angefgt:\n \\n <PDF-Dateiname>_<Nutzdatenticket>.pdf\n Optional kann der PDF-Dateiname den Platzhalter \"%t\" enthalten, der dann\n durch das Nutzdatenticket ersetzt wird:\n \\n \"%t_ericprint.pdf\" --> \"<Nutzdatenticket>_ericprint.pdf\"\n\n @note Es ist sicherzustellen, dass alle PDF-Dateien im Dateisystem\n erstellt bzw. geschrieben werden knnen.  Falls es beim Erstellen der\n PDF-Dokumente einen Fehler gibt oder falls diese nicht geschrieben\n werden knnen, wird die Bearbeitung abgebrochen, eine Log-Ausgabe\n erstellt, aus der hervorgeht, welcher Steuerfall nicht gedruckt werden\n konnte, und eine Fehlermeldung an den Aufrufer zurckgeliefert."]
    pub pdfName: *const byteChar,
    #[doc = " @brief Futext der auf dem Ausdruck verwendet werden soll (optional).\n @details Wenn der bergebene Text lnger als #ERIC_MAX_LAENGE_FUSSTEXT\n Zeichen ist, dann bricht der Druck mit Fehlerkode\n #ERIC_PRINT_FUSSTEXT_ZU_LANG ab!\n\n @note Fachliche Informationen sind im ERiC-Entwicklerhandbuch.pdf nachzulesen."]
    pub fussText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_druck_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_druck_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_druck_parameter_t>(),
        32usize,
        concat!("Size of: ", stringify!(eric_druck_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_druck_parameter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(eric_druck_parameter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vorschau) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(vorschau)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ersteSeite) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(ersteSeite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duplexDruck) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(duplexDruck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdfName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(pdfName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fussText) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(fussText)
        )
    );
}
#[doc = " @brief Fr die Signatur oder Authentifizierung bentigte\n Informationen.\n\n Diese Struktur ist vom Anwender zu allokieren und samt\n Inhalt auch wieder freizugeben."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_verschluesselungs_parameter_t {
    #[doc = " @brief Version dieser Struktur. Muss derzeit immer 2 sein.\n        Bei nderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 2 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Verweis auf den KeyStore, siehe EricGetHandleToCertificate()."]
    pub zertifikatHandle: EricZertifikatHandle,
    #[doc = " @brief PIN fr den KeyStore."]
    pub pin: *const ::std::os::raw::c_char,
    #[doc = " @brief Dieser muss fr Datenlieferungen zum Verfahren\nElsterDatenabholung und Datenart ElsterVaStDaten\nangegeben werden, falls fr die Signatur ein\nSoftPSE-Zertifikat verwendet wird. In allen anderen Fllen\nmuss hier NULL bergeben werden. Der Parameter abrufCode\nbesteht aus 2 x 5 Zeichen, die mit \"-\" verbunden sind.\n\\b Beispiel: \"K6FG5-RS32P\""]
    pub abrufCode: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_verschluesselungs_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_verschluesselungs_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_verschluesselungs_parameter_t>(),
        24usize,
        concat!("Size of: ", stringify!(eric_verschluesselungs_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_verschluesselungs_parameter_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eric_verschluesselungs_parameter_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zertifikatHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(zertifikatHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abrufCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(abrufCode)
        )
    );
}
#[doc = " @brief Struktur mit Informationen zur Erzeugung von Zertifikaten mit #EricCreateKey.\n\n Die Elemente der Struktur beschreiben den Anwender, fr den ein Schlssel erstellt werden soll.\n Unbenutzte Parameter mssen mit NULL oder Leerstring initialisiert werden.\n\n Diese Struktur und ihre Elemente sind vom Anwender zu allokieren und samt Inhalt auch wieder freizugeben.\n Alle Elemente sind vom Anwender zu initialisieren.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_zertifikat_parameter_t {
    #[doc = " @brief Version dieser Struktur. Muss derzeit immer 1 sein.\n        Bei nderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 1 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurckgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Name des Anwenders.\n\n Die Angabe des Namens ist obligatorisch.\n Der Parameter darf nicht mit NULL oder einem Leerstring belegt werden."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " @brief Land (Lnderkrzel) des Anwenders. \\b Beispiel: \"DE\".\n\n Die Angabe dieses Wertes ist optional."]
    pub land: *const ::std::os::raw::c_char,
    #[doc = " @brief Wohnort des Anwenders, inklusive PLZ. \\b Beispiel: \"D-10179 Berlin\".\n\n Die Angabe dieses Wertes ist optional."]
    pub ort: *const ::std::os::raw::c_char,
    #[doc = " @brief Straenangabe mit Hausnummer des Anwenders mit Zustzen, \\b Beispiel: \"Musterstrae 123 Zugang im Rckgebude\".\n\n Die Angabe dieses Wertes ist optional."]
    pub adresse: *const ::std::os::raw::c_char,
    #[doc = " @brief E-Mail-Adresse des Anwenders.\n\n Die Angabe dieses Wertes ist optional."]
    pub email: *const ::std::os::raw::c_char,
    #[doc = " @brief Name der Organisation.\n\n Die Angabe dieses Wertes ist optional.\n Wenn \\c organisation und \\c abteilung nicht angegeben werden, wird \"ELSTER\" verwendet."]
    pub organisation: *const ::std::os::raw::c_char,
    #[doc = " @brief Name der Abteilung (organizational unit) der Organisation.\n\n Die Angabe dieses Wertes ist optional.\n Wenn \\c organisation und \\c abteilung nicht angegeben werden, wird \"ERiC\" verwendet."]
    pub abteilung: *const ::std::os::raw::c_char,
    #[doc = " @brief Beschreibung, welche fr den Anwender im Zertifikat abgelegt wird.\n\n Die Angabe dieses Wertes ist optional."]
    pub beschreibung: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_zertifikat_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_zertifikat_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_zertifikat_parameter_t>(),
        72usize,
        concat!("Size of: ", stringify!(eric_zertifikat_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_zertifikat_parameter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(eric_zertifikat_parameter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).land) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(land)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ort) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(ort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adresse) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(adresse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).email) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).organisation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(organisation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abteilung) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(abteilung)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beschreibung) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(beschreibung)
        )
    );
}
#[doc = " Fehler, der zum Programmabbruch fhrt."]
pub const eric_log_level_t_ERIC_LOG_ERROR: eric_log_level_t = 4;
#[doc = " Hinweise auf Zustnde, die zu Fehlern fhren knnen."]
pub const eric_log_level_t_ERIC_LOG_WARN: eric_log_level_t = 3;
#[doc = " Grobe Informationen ber den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_INFO: eric_log_level_t = 2;
#[doc = " Feingranulare Informationen ber den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_DEBUG: eric_log_level_t = 1;
#[doc = " Sehr feingranulare Informationen ber den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_TRACE: eric_log_level_t = 0;
#[doc = " ::eric_log_level_t ist ein Parameter fr Funktionen vom Typ ::EricLogCallback.\n Der Loglevel kann zum Filtern fr das ERiC Protokoll verwendet werden, siehe\n ERiC-Entwicklerhandbuch.pdf Kap. \"Das ERiC Protokoll eric.log\"."]
pub type eric_log_level_t = ::std::os::raw::c_uint;
#[doc = " @brief Typ der Callback-Funktion zum Logging.\n\n Wenn registriert, wird diese Callback-Funktion\n fr jeden Log-Eintrag mit folgenden Parametern aufgerufen.\n\n @param kategorie Kategorie des Logeintrags. Beinhaltet das Modul, welches\n                  den Log-Eintrag ausgibt. Zum Beispiel \"eric.ctrl2\". Kann\n                  zum Filtern verwendet werden. Alle Log-Nachrichten besitzen\n                  eine Kategorie. Der Zeiger ist nur innerhalb dieser\n                  Funktion gltig.\n\n @param loglevel Log-Level des Logeintrags. Kann zum Filtern verwendet werden.\n\n @param nachricht Enthlt die Log-Nachricht als Zeichenkette. Der Zeiger ist\n                  nur innerhalb dieser Funktion gltig.\n\n @param benutzerdaten Der Zeiger, der bei der Registrierung mit\n                      ::EricRegistriereLogCallback() bergeben worden ist,\n                      wird in diesem Parameter vom ERiC unverndert\n                      bergeben.\n\n @see\n      - ::EricRegistriereLogCallback()\n"]
pub type EricLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        kategorie: *const ::std::os::raw::c_char,
        loglevel: eric_log_level_t,
        nachricht: *const ::std::os::raw::c_char,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief \\c id, die beim Einlesen des XMLs von Fortschrittcallbacks\n        ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_EINLESEN: _bindgen_ty_1 = 10;
#[doc = " @brief \\c id, die gemeldet wird, wenn die Daten zum Versand noch\n        vorbereitet werden mssen."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_VORBEREITEN: _bindgen_ty_1 = 20;
#[doc = " @brief \\c id, die beim Validieren der Eingangsdaten von\n        Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_VALIDIEREN: _bindgen_ty_1 = 30;
#[doc = " @brief \\c id, die beim Versand der Ausgangsdaten von\n       Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_SENDEN: _bindgen_ty_1 = 40;
#[doc = " @brief \\c id, die beim Druck der Eingangsdaten von\n        Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_DRUCKEN: _bindgen_ty_1 = 50;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " @brief Typ der Callback-Funktionen, die am ERiC fr Fortschrittanzeigen\n        registriert werden knnen.\n\n @param id Aktueller Verarbeitungsschritt\n\n @param pos Aktueller Fortschritt bezogen auf \\c max\n\n @param max Maximalwert des aktuellen Fortschritts \\c pos\n\n @param benutzerdaten Der Zeiger, der bei der Registrierung mit\n                      ::EricRegistriereGlobalenFortschrittCallback() oder\n                      ::EricRegistriereFortschrittCallback() bergeben\n                      worden ist, wird in diesem Parameter vom ERiC\n                      unverndert bergeben.\n\n @details Es gilt stets, dass:\n           - \\c pos grer oder gleich 0 und kleiner oder gleich \\c max ist\n           - \\c max ist immer grer als 0"]
pub type EricFortschrittCallback = ::std::option::Option<
    unsafe extern "C" fn(id: u32, pos: u32, max: u32, benutzerdaten: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Diese API-Funktion ist die zentrale Schnittstellenfunktion zur Kommunikation\n        mit dem ELSTER-Annahmeserver.\n\n Als Austauschformat wird XML verwendet, siehe Kapitel \"Datenverarbeitung mit ERiC\"\n im Entwicklerhandbuch. Dort sind die Arbeitsablufe von Einzel- und Sammellieferung\n beschrieben.\n\n Die Funktion kann Steuerdaten plausibilisieren, an den ELSTER-Annahmeserver bertragen und\n ausdrucken, sowie Protokolle der bertragung erzeugen. Die ProcessingFlags im Parameter\n @c bearbeitungsFlags definieren, welche der Schritte wie ausgefhrt werden.\n\n Je nach Anwendungsfall knnen die Daten authentifiziert bertragen werden und es kann\n ein PDF-Druck der Daten erfolgen. In diesen Fllen sind die Parameter @c cryptoParameter\n und @c druckParameter entsprechend zu befllen. Die mglichen Parameterkombinationen und\n Druckkennzeichnungen knnen im Entwicklerhandbuch nachgelesen werden.\n\n Sind fr einen Anwendungsfall mehrere voneinander abhngige Aufrufe von\n ::EricBearbeiteVorgang() ntig, so ist der Parameter @c transferHandle zu bergeben. Dies\n ist derzeit nur fr die Datenabholung der Fall.\n\n Es werden an bestimmten Punkten der Verarbeitung benutzerdefinierte Callback Funktionen\n aufgerufen. Siehe hierzu \\ref STSection_Fortschrittcallbacks.\n\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] datenpuffer\n              Enthlt die zu verarbeitenden XML-Daten.\n @param[in] datenartVersion\n              Die @c datenartVersion ist der Datenartversionmatrix zu entnehmen,\n              siehe Dokumentation\\Datenartversionmatrix.xml und ERiC-Entwicklerhandbuch.pdf.\n              Dieser Parameter darf nicht NULL sein und muss zu den XML-Eingangsdaten passen.\n @param[in] bearbeitungsFlags\n              Oder-Verknpfung von Bearbeitungsvorgaben.\n              Anhand dieser Vorgaben werden die bergebenen Daten verarbeitet.\n              Der Parameter darf nicht 0 sein, zu gltigen Werten siehe ::eric_bearbeitung_flag_t.\n              Bei welchen Anwendungsfllen welche Flags mglich oder notwendig sind,\n              ist im Entwicklerhandbuch nachzulesen.\n @param[in] druckParameter\n              Parameter, der fr den PDF-Druck bentigt wird, siehe\n              ::eric_druck_parameter_t.\n              Bei welchen Anwendungsfllen der Druckparameter mglich oder notwendig ist,\n              ist im Entwicklerhandbuch nachzulesen. Soll kein PDF-Druck erfolgen,\n              so ist NULL zu bergeben.\n @param[in] cryptoParameter\n              Enthlt die fr den authentifizierten Versand bentigten\n              Informationen und darf nur dann bergeben werden,\n              siehe ::eric_verschluesselungs_parameter_t.\n              Erfolgt kein authentifizierter Versand, so ist NULL zu bergeben.\n @param[in,out] transferHandle\n              Bei der Datenabholung ist ein Zeiger auf ein vom Aufrufer verwaltetes\n              und anfangs mit 0 beflltes ::EricTransferHandle zu bergeben, ber das die\n              zusammenhngenden Versandvorgnge einer Datenabholung gebndelt werden\n              (Bndelung der Versandvorgnge \"Anforderung\", \"Abholung\" und optional\n              \"Quittierung\").\n              Wenn bei der Datenabholung kein Versandflag gesetzt ist (nur Validierung),\n              darf dem transferHandle auch ein Nullzeiger (NULL) bergeben werden.\n              Bei allen anderen Anwendungsfllen ist immer NULL zu bergeben.\n @param[out] rueckgabeXmlPuffer\n              Handle auf einen Rckgabepuffer, in den beim Versand\n              Telenummer und Ordnungsbegriff, Hinweise oder Fehler bei der\n              Regelprfung geschrieben werden, siehe\n              \\ref STSection_Rueckgabepuffer und ::EricRueckgabepufferHandle.\n @param[out] serverantwortXmlPuffer\n              Handle auf einen Rckgabepuffer, in den beim Versand die\n              Antwort des Empfangsservers geschrieben wird, siehe\n              \\ref STSection_Rueckgabepuffer und ::EricRueckgabepufferHandle.\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n        - ::ERIC_GLOBAL_VERSCHLUESSELUNGS_PARAMETER_NICHT_ANGEGEBEN\n        - ::ERIC_GLOBAL_PRUEF_FEHLER\n          Plausibilittsfehler in den Eingabedaten, die Fehlermeldungen\n          werden im Rckgabepuffer @c rueckgabeXmlPuffer zurckgegeben.\n          Siehe Abschnitt \\ref STSection_Plausibilitaetsfehler.\n        - ::ERIC_GLOBAL_HINWEISE\n          Kann nur zurckgegeben werden, falls das Bearbeitungsflag\n          ::ERIC_PRUEFE_HINWEISE angegeben wurde.\n          Es wurden ausschlielich Hinweise zu den Eingabedaten gemeldet,\n          die Hinweise werden im Rckgabepuffer @c rueckgabeXmlPuffer zurckgegeben.\n          Siehe Abschnitt \\ref STSection_Hinweise.\n        - ::ERIC_GLOBAL_DATENSATZ_ZU_GROSS\n          Die maximal zulssige Gre des XML-Eingangsdatensatzes oder des zu bermittelnden,\n          komprimierten, verschlsselten und base64-kodierten Datenteils,\n          siehe ERiC-Entwicklerhandbuch.pdf Kap. \"Grenbegrenzung der\n          Eingangsdaten\", ist berschritten.\n        - ::ERIC_TRANSFER_ERR_XML_THEADER, ::ERIC_TRANSFER_ERR_XML_NHEADER\n          Die Serverantwort enthlt Fehlermeldungen. Zur Auswertung kann\n          entweder die Serverantwort selbst ausgewertet werden oder es wird\n          ::EricGetErrormessagesFromXMLAnswer() aufgerufen.\n        - ::ERIC_IO_READER_SCHEMA_VALIDIERUNGSFEHLER\n        - ::ERIC_IO_PARSE_FEHLER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - weitere, siehe eric_fehlercodes.h\n\n \\section STSection_Rueckgabepuffer Inhalt des Rckgabepuffers und des Serverantwortpuffers\n\n Der Inhalt der Pufferspeicher kann mit ::EricRueckgabepufferInhalt() abgefragt\n und ausgewertet werden. @c rueckgabeXmlPuffer gibt im \\ref STSection_Erfolgsfall oder bei\n \\ref STSection_Plausibilitaetsfehler XML-Daten nach Schema\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd zurck.\n @c serverantwortXmlPuffer gibt bei Sendevorgngen die Antwort des ELSTER-\n Annahmeservers zurck.\n\n Nach dem Aufruf der Funktion mssen programmatisch folgende Flle aufgrund des Rckgabewerts\n unterschieden werden.\n\n \\subsection STSection_Erfolgsfall Erfolgsfall\n\n Sind alle Bearbeitungsschritte fehlerfrei durchlaufen worden, dann ist\n der Rckgabewert ::ERIC_OK und der Text im Pufferspeicher\n @c rueckgabeXmlPuffer enthlt beim Versand XML-Daten mit generierter\n Telenummer und bei Neuaufnahmen den Ordnungsbegriff.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\"\n    <Erfolg>\n        <Telenummer>N55</Telenummer>\n    </Erfolg>\n </EricBearbeiteVorgang>\n \\endcode\n\n Beim Versand befindet sich zustzlich im Pufferspeicher @c serverantwortXmlPuffer die Antwort\n des ELSTER-Annahmeservers. Bei einer Datenabholung kann diese ausgewertet werden. Details\n hierzu befinden sich im Entwicklerhandbuch.\n\n \\subsection STSection_Hinweise Hinweise\n\n Falls das Bearbeitungsflag ::ERIC_PRUEFE_HINWEISE angegeben worden ist, kann der\n Rckgabewert ::ERIC_GLOBAL_HINWEISE zurckgegeben werden.\n Der Rckgabepuffer enthlt dann die gemeldeten Hinweise.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\">\n    <Hinweis>\n        <Nutzdatenticket>1075</Nutzdatenticket>\n        <Feldidentifikator>100001</Feldidentifikator>\n        <Mehrfachzeilenindex>1</Mehrfachzeilenindex>\n        <LfdNrVordruck>1</LfdNrVordruck>\n        <VordruckZeilennummer>4</VordruckZeilennummer>\n        <SemantischerIndex>PersonA</SemantischerIndex>\n        <Untersachbereich>5</Untersachbereich>\n        <RegelName>testRegelName</RegelName>\n        <FachlicheHinweisId>9995</FachlicheHinweisId>\n        <Text>Weitere Angaben knnen erforderlich sein</Text>\n    </Hinweis>\n </EricBearbeiteVorgang>\n \\endcode\n\n Die einzelnen Elemente sind in der Schemadefinition\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd dokumentiert.\n Wenn die Bearbeitungsflags ::ERIC_PRUEFE_HINWEISE und ::ERIC_VALIDIERE bergeben\n worden sind, wurden bei der Plausibilisierung keine Fehler gefunden. Es sind\n keine Fehler im Rckgabepuffer enthalten.\n\n \\subsection STSection_Plausibilitaetsfehler Plausibilittsfehler\n\n Bei fehlgeschlagener Plausibilittsprfung ist der Rckgabewert\n ::ERIC_GLOBAL_PRUEF_FEHLER, und die Fehler werden im Rckgabepuffer\n als XML-Daten zurckgeliefert.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\">\n    <FehlerRegelpruefung>\n        <Nutzdatenticket>1075</Nutzdatenticket>\n        <Feldidentifikator>100001</Feldidentifikator>\n        <Mehrfachzeilenindex>1</Mehrfachzeilenindex>\n        <LfdNrVordruck>1</LfdNrVordruck>\n        <VordruckZeilennummer>4</VordruckZeilennummer>\n        <SemantischerIndex>PersonA</SemantischerIndex>\n        <Untersachbereich>5</Untersachbereich>\n        <RegelName>testRegelName</RegelName>\n        <FachlicheFehlerId>9995</FachlicheFehlerId>\n        <Text>Beim Ankreuzfeld muss der Wert 'X' angegeben werden.</Text>\n    </FehlerRegelpruefung>\n </EricBearbeiteVorgang>\n \\endcode\n\n Die einzelnen Elemente sind in der Schemadefinition\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd dokumentiert.\n Wenn die Bearbeitungsflags ::ERIC_PRUEFE_HINWEISE und ::ERIC_VALIDIERE bergeben\n worden sind, kann der Rckgabepuffer auch Hinweise enthalten.\n\n \\subsection STSection_Serverfehlerfall Fehler in der Serverantwort\n\n Ist der Rckgabewert ::ERIC_TRANSFER_ERR_XML_THEADER oder\n ::ERIC_TRANSFER_ERR_XML_NHEADER so enthlt der Serverantwortpuffer\n Fehlermeldungen. Zur Auswertung kann entweder die Serverantwort selbst\n ausgewertet werden oder es wird ::EricGetErrormessagesFromXMLAnswer() aufgerufen.\n\n \\subsection STSection_Fehler Sonstige Fehler\n\n Bei sonstigen Fehlern ist der Inhalt der Rckgabepuffer undefiniert. Um nhere\n Informationen ber die Fehlerursache herauszufinden, kann ::EricHoleFehlerText() mit\n dem Rckgabewert aufgerufen werden.\n\n \\section STSection_Fortschrittcallbacks Fortschrittcallbacks\n\n Whrend der Verarbeitung eines Anwendungsfalls werden die durch die Funktionen\n ::EricRegistriereFortschrittCallback() und ::EricRegistriereGlobalenFortschrittCallback()\n registrierten Callbacks aufgerufen.\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Anwendungsflle von EricBearbeiteVorgang()\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel der jeweiligen Datenart\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Datenabholung\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Grenbegrenzung der Eingangsdaten\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Funktionen fr Fortschrittcallbacks\"\n      - EricHoleFehlerText()\n      - EricGetErrormessagesFromXMLAnswer()\n      - EricRegistriereFortschrittCallback()\n      - EricRegistriereGlobalenFortschrittCallback()\n"]
    pub fn EricBearbeiteVorgang(
        datenpuffer: *const ::std::os::raw::c_char,
        datenartVersion: *const ::std::os::raw::c_char,
        bearbeitungsFlags: u32,
        druckParameter: *const eric_druck_parameter_t,
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        transferHandle: *mut EricTransferHandle,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
        serverantwortXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Beendet den Singlethreading-ERiC\n\n Die Verarbeitung mit der ERiC Singlethread-API ist beendet, als letztes muss EricBeende() aufgerufen werden.\n\n @return\n          - ::ERIC_OK\n          - ::ERIC_GLOBAL_NICHT_INITIALISIERT\n          - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n          - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n          - EricInitialisiere()"]
    pub fn EricBeende() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die PIN fr ein clientseitig erzeugtes Zertifikat (CEZ) wird gendert.\n\n Die Funktion ndert die bei der Funktion EricCreateKey() angegebene PIN\n und entsprechend hierfr die Prfsumme in der Datei eric.sfv.\n Falls die Datei eric.sfv nicht vorhanden ist, wird sie, wie bei EricCreateKey(), erstellt.\n Eine PIN-nderung von einem Portalzertifikat (POZ) ist nicht mglich.\n\n Pfade mssen auf Windows in der fr Datei-Funktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 bergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Fr Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"bergabe von Pfaden an ERiC API-Funktionen\"\n\n @param[in] psePath\n            In dem angegebenen Pfad liegt das Schlsselpaar\n            (eric_private.p12 und eric_public.cer).\n @param[in] oldPin\n            Bisherige PIN.\n @param[in] newPin\n            Neue PIN. Die Mindestlnge betrgt 4 Stellen. Zulssige\n            Zeichen sind alle ASCII-Zeichen ohne die Steuerzeichen.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n         - ::ERIC_CRYPT_PIN_STAERKE_NICHT_AUSREICHEND\n         - ::ERIC_CRYPT_PIN_ENTHAELT_UNGUELTIGE_ZEICHEN\n         - ::ERIC_CRYPT_E_PSE_PATH\n         - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n         - ::ERIC_CRYPT_ERROR_CREATE_KEY\n\n\n @see\n         - EricCreateKey()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zuordnung der API-Funktionen zur Verwendung von POZ, CEZ und AHZ\""]
    pub fn EricChangePassword(
        psePath: *const byteChar,
        oldPin: *const byteChar,
        newPin: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Bundesfinanzamtsnummer wird berprft.\n\n Wird eine 13-stellige Steuernummer im\n ELSTER-Steuernummernformat angegeben, so wird nur die\n Bundesfinanzamtsnummer (= die ersten 4 Stellen der\n 13-stelligen Steuernummer) geprft.\n\n Eine Prfung der Steuernummer selbst findet nicht statt\n (hierfr EricPruefeSteuernummer() verwenden).\n\n @param[in] steuernummer\n            13-stellige Steuernummer im ELSTER Steuernummernformat bzw.\n            4-stellige Bundesfinanzamtsnummer.\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_BUFANR_UNBEKANNT:\n           Die Bundesfinanzamtsnummer ist unbekannt oder ungltig.\n         - ::ERIC_GLOBAL_NULL_PARAMETER:\n           Es wurde keine Bundesfinanzamtsnummer bergeben (Parameter ist NULL).\n         - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricPruefeSteuernummer()\n      - Pruefung_der_Steuer-_und_Steueridentifikatsnummer.pdf"]
    pub fn EricPruefeBuFaNummer(steuernummer: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Das @c xml wird gegen das Schema der @c datenartVersion validiert.\n\n Das verwendete Schema kann unter Dokumentation\\\\Schnittstellenbeschreibungen\\\\ nachgeschlagen werden.\n \\n Nicht untersttzte Datenartversionen:\n  - ElsterKMV\n  - alle Bilanz Datenartversionen\n\n @param[in]  xml\n             XML-Zeichenfolge\n @param[in]  datenartVersion\n             Die @c datenartVersion ist der Datenartversionmatrix zu entnehmen,\n             siehe Dokumentation\\Datenartversionmatrix.xml und ERiC-Entwicklerhandbuch.pdf.\n             Dieser Parameter darf nicht NULL sein und muss zu den XML-Eingangsdaten passen.\n @param[out] fehlertextPuffer Handle auf einen Rckgabepuffer, in den\n             Fehlertexte geschrieben werden.\n             Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_FUNKTION_NICHT_UNTERSTUETZT: Schemavalidierung wird fr die bergebene @c datenartVersion nicht untersttzt.\n         - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n         - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_IO_READER_SCHEMA_VALIDIERUNGSFEHLER: Die Fehlerbeschreibung steht im fehlertextPuffer.\n         - ::ERIC_IO_PARSE_FEHLER: Die Fehlerbeschreibung steht im fehlertextPuffer.\n         - weitere, siehe eric_fehlercodes.h"]
    pub fn EricCheckXML(
        xml: *const ::std::os::raw::c_char,
        datenartVersion: *const ::std::os::raw::c_char,
        fehlertextPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Das Zertifikat-Handle @c hToken wird freigegeben.\n\n Diese Funktion gibt das bergebene Zertifikat-Handle frei.\n Zertifikat-Handles sollten mglichst frhzeitig, d.h. wenn sie nicht\n mehr bentigt werden, mit EricCloseHandleToCertificate() freigegeben\n werden, sptestens jedoch zum Programmende bzw. vor dem Entladen der\n ericapi Bibliothek.\n Das Ad Hoc-Zertifikat eines neuen Personalausweises sollte immer genau\n dann freigegeben werden, wenn es nicht mehr bentigt wird, jedoch sptestens\n vor Ablauf der 24 Stunden, die das Ad Hoc-Zertifikat gltig ist.\n Tritt ein Fehler auf, kann die Fehlermeldung mit EricHoleFehlerText()\n ausgelesen werden.\n\n @param[in] hToken\n            Zertifikat-Handle wie von der Funktion\n            EricGetHandleToCertificate() zurckgeliefert.\n @return\n         - ::ERIC_OK\n         - ::ERIC_CRYPT_E_INVALID_HANDLE\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n \\n\\n <b>Nur bei Verwendung des neuen Personalausweises:</b>\n         - ::ERIC_TRANSFER_EID_CLIENTFEHLER\n         - ::ERIC_TRANSFER_EID_FEHLENDEFELDER\n         - ::ERIC_TRANSFER_EID_IDENTIFIKATIONABGEBROCHEN\n         - ::ERIC_TRANSFER_EID_NPABLOCKIERT\n         - ::ERIC_TRANSFER_EID_IDNRNICHTEINDEUTIG\n         - ::ERIC_TRANSFER_EID_KEINCLIENT\n         - ::ERIC_TRANSFER_EID_KEINKONTO\n         - ::ERIC_TRANSFER_EID_SERVERFEHLER\n         - ::ERIC_TRANSFER_ERR_CONNECTSERVER\n         - ::ERIC_TRANSFER_ERR_NORESPONSE\n         - ::ERIC_TRANSFER_ERR_PROXYAUTH\n         - ::ERIC_TRANSFER_ERR_PROXYCONNECT\n         - ::ERIC_TRANSFER_ERR_SEND\n         - ::ERIC_TRANSFER_ERR_SEND_INIT\n         - ::ERIC_TRANSFER_ERR_TIMEOUT\n\n @see\n         - EricGetHandleToCertificate()\n         - EricGetPinStatus()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Authentifizierung mit dem neuen Personalausweis (nPA)\""]
    pub fn EricCloseHandleToCertificate(hToken: EricZertifikatHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es werden die Kryptomittel fr ein clientseitig erzeugtes\n        Zertifikat (CEZ) in einem Verzeichnis des Dateisystems\n        erstellt.\n\n Im angegebenen Verzeichnis @c pfad sind nach Ausfhrung\n der Funktion EricCreateKey() drei Dateien erstellt worden:\n - eric_public.cer: Enthlt das Zertifikat mit den Daten aus\n   @c zertifikatInfo und darin den ffentlichen Schlssel.\n - eric_private.p12: Enthlt den privaten Schlssel. Der\n   Zugriff ist ber die @c pin geschtzt.\n - eric.sfv: Enthlt die Prfsumme der Dateien\n   eric_public.cer und eric_private.p12. Die Integritt\n   dieser beiden Dateien kann damit jederzeit berprft werden.\n\n Ein CEZ kann unter anderem fr die\n Bescheiddaten-Rckbermittlung verwendet werden.\n Weitere Informationen zur Datenabholung lesen Sie bitte im\n ERiC-Entwicklerhandbuch.pdf nach.\n\n ber eine Meldung sollte der Benutzer darauf hingewiesen\n werden, dass die Generierung der Kryptomittel je nach\n Leistungsfhigkeit der verwendeten Hardware bis zu einigen Minuten\n dauern kann.\n\n @param[in] pin\n            PIN (Passwort), mit der auf den privaten Schlssel\n            zugegriffen werden kann.\n            \\n Die Mindestlnge betrgt 4 Stellen. Zulssige\n            Zeichen sind alle ASCII-Zeichen ohne die\n            Steuerzeichen.\n @param[in] pfad\n            Pfad (1) in dem die Kryptomittel erzeugt werden sollen.\n            Das durch den angegebenen\n            Pfad bezeichnete Verzeichnis muss im Dateisystem\n            bereits existieren und beschreibbar sein.\n            Es gibt folgende Mglichkeiten:\n            - Absoluter Pfad: Empfehlung\n            - Relativer Pfad: Wird an das Arbeitsverzeichnis\n              angehngt\n            - Leere Zeichenkette: In diesem Fall wird das\n              Arbeitsverzeichnis verwendet.<br>\n @param[in] zertifikatInfo\n            Daten, die zur Identifikation des Schlsselinhabers\n            im Zertifikat abgelegt werden.\n\n (1) Pfade mssen auf Windows in der fr Datei-Funktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 bergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Fr Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"bergabe von Pfaden an ERiC API-Funktionen\".\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n - ::ERIC_CRYPT_ZERTIFIKATSPFAD_KEIN_VERZEICHNIS\n - ::ERIC_CRYPT_ZERTIFIKATSDATEI_EXISTIERT_BEREITS\n - ::ERIC_CRYPT_PIN_STAERKE_NICHT_AUSREICHEND\n - ::ERIC_CRYPT_PIN_ENTHAELT_UNGUELTIGE_ZEICHEN\n - ::ERIC_CRYPT_ERROR_CREATE_KEY\n\n @see\n     - EricChangePassword()\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zertifikate und Authentifizierungsverfahren\"\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"bergabe von Pfaden an ERiC API-Funktionen\""]
    pub fn EricCreateKey(
        pin: *const byteChar,
        pfad: *const byteChar,
        zertifikatInfo: *const eric_zertifikat_parameter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Diese Funktion erzeugt einen TransferHeader.\n\n Dieser ist der oberste Header in der Datenstruktur.\n Er enthlt Felder fr die Kommunikation zwischen Server\n und Client. Es wird nur die Kombination\n NutzdatenHeader-Version \"11\" und TransferHeader-Version \"11\" untersttzt.\n\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] xml\n            XML-Datensatz, fr den der TransferHeader erzeugt werden soll.\n            \\n Es kann entweder ein komplettes Elster-XML oder nur der Datenteil bergeben werden.\n            \\n ERiC nimmt bei diesem Parameter keine Konvertierung von Sonderzeichen in Entittenreferenzen vor.\n            \\n Attribute, die in den Start-Tags der Elemente \"Elster\"\n            bzw. \"DatenTeil\" im bergebenen XML-Datensatz definiert werden, werden nicht in\n            das Rckgabe-XML bernommen.\n            \\n Namespace-Definitionen, die in den Start-Tags der Elemente \"Elster\"\n            bzw. \"DatenTeil\" im bergebenen XML-Datensatz definiert werden, fhren zu einem ERIC_IO_PARSE_FEHLER.\n            \\n Im Rckgabe-XML werden im Start-Tag des Elements \"Elster\" die URI \"http://www.elster.de/elsterxml/schema/v11\" als\n            Default-Namensraum definiert. Die dem Element \"DatenTeil\"\n            untergeordneten Elemente aus dem bergebenen XML-Datensatz werden\n            unverndert bernommen.\n            \\n Der allgemeine Aufbau des Elster-XMLs wird im\n            ERiC-Entwicklerhandbuch.pdf im Kapitel \"Datenverarbeitung mit\n            ERiC\" beschrieben.\n @param[in] verfahren\n            Name des Verfahrens, z.B:\n            'ElsterAnmeldung', siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] datenart\n            Name der Datenart, z.B.:'LStB' oder 'UStVA',\n            siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] vorgang\n            Name der bertragungsart, z.B.\n            'send-NoSig', siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] testmerker\n            Fr eine Testbertragung muss der entsprechende Testmerker angegeben werden,\n            siehe ERiC-Entwicklerhandbuch.pdf, Kap. \"Test Untersttzung bei der\n            ERiC-Anbindung\". Falls ein Echtfall bertragen werden soll, muss der Wert NULL angegeben werden.\n @param[in] herstellerId\n            Hersteller-ID des Softwareproduktes.\n @param[in] datenLieferant\n            Der Wert entspricht dem XML-Element \"DatenLieferant\", wie es im\n            Schema des Transferheaders der ElsterBasis-XML-Schnittstelle\n            definiert ist.\n            \\n ERiC konvertiert bei diesem Parameter Sonderzeichen in Entittenreferenzen.\n @param[in] versionClient\n            Angabe von Versionsinformation, die in der Serverantwort\n            auch zurckgegeben wird und ausgewertet werden kann.\n            Der Wert NULL entspricht \"keine Angabe von Versionsinformation\",\n            d.h. es wird kein Element VersionClient im Transferheader erzeugt.\n            \\n ERiC konvertiert bei diesem Parameter Sonderzeichen in Entittenreferenzen.\n @param[in] publicKey\n            ffentlicher Schlssel fr die Transportverschlsselung beim Verfahren\n            ElsterLohn. Bei anderen Verfahren sollte NULL bergeben werden.\n            Dieser Wert kann mit dem Rckgabewert von ::EricGetPublicKey() befllt\n            werden.\n            Der Inhalt dieses Parameters wird in das \\<TransportSchluessel>-\n            Element der Rckgabe-XML geschrieben.\n @param[out] xmlRueckgabePuffer Handle auf einen Rckgabepuffer, in den\n            das Elster-XML mit dem erzeugten TransportHeader geschrieben wird,\n            siehe ::EricRueckgabepufferHandle. Es wird immer ein vollstndiger\n            Elster-XML-Datensatz mit dem \"Elster\"-Element als Wurzel-Element\n            zurckgeliefert. Bzgl. der darin enthaltenen XML-Namespace-Definitionen sind\n            die bei der Beschreibung des Parameters \"xml\" genannten Einschrnkungen\n            zu bercksichtigen.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_TRANSFER_ERR_XML_ENCODING: Die bergebenen XML-Daten sind\n                  nicht UTF-8 kodiert.\n         - ::ERIC_IO_PARSE_FEHLER\n         - ::ERIC_IO_DATENTEILNOTFOUND\n         - ::ERIC_IO_DATENTEILENDNOTFOUND\n         - weitere, siehe eric_fehlercodes.h\n\n\n @see\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Datenverarbeitung mit ERiC\"\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Anwendungsflle von EricBearbeiteVorgang()\"\n     - ERiC-Returncodes und Fehlertexte sind in eric_fehlercodes.h zu finden."]
    pub fn EricCreateTH(
        xml: *const ::std::os::raw::c_char,
        verfahren: *const ::std::os::raw::c_char,
        datenart: *const ::std::os::raw::c_char,
        vorgang: *const ::std::os::raw::c_char,
        testmerker: *const ::std::os::raw::c_char,
        herstellerId: *const ::std::os::raw::c_char,
        datenLieferant: *const ::std::os::raw::c_char,
        versionClient: *const ::std::os::raw::c_char,
        publicKey: *const byteChar,
        xmlRueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @brief Es werden die mit der Datenabholung abgeholten und verschlsselten Daten entschlsselt.\n\n  Falls whrend der Bearbeitung ein Fehler auftritt,\n  liefert die Funktion EricHoleFehlerText() den\n  dazugehrigen Fehlertext.\n\n @param[in] zertifikatHandle Handle auf das zum Entschlsseln zu verwendende Zertifikat.\n @param[in] pin PIN zum Zugriff auf das Zertifikat.\n @param[in] base64Eingabe Base64-kodierte verschlsselte Daten oder Anhnge, welche mit dem Verfahren\n                          ElsterDatenabholung abgeholt wurden. Die Abholdaten befinden sich im Element\n                          /Elster[1]/DatenTeil[1]/Nutzdatenblock/Nutzdaten[1]/Datenabholung[1]/Abholung[1]/Datenpaket.\n                          Die optionalen Anhnge befinden sich im Element\n                          /Elster[1]/DatenTeil[1]/Nutzdatenblock/Nutzdaten[1]/Datenabholung[1]/Abholung[1]/Anhaenge[1]/Anhang[1]/Dateiinhalt.\n @param[out] rueckgabePuffer Handle auf einen Rckgabepuffer, in den\n            die entschlsselten Daten geschrieben werden. Im Fehlerfall ist der Inhalt des Rckgabepuffers undefiniert.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_ERR_DEKODIEREN\n  - ::ERIC_GLOBAL_UNKNOWN\n  - Ein Zertifikatsfehler aus dem Statuscodebereich von ::ERIC_CRYPT_E_INVALID_HANDLE = 610201101 bis 610201212\n\n @see\n      - EricHoleFehlerText()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Datenabholung\""]
    pub fn EricDekodiereDaten(
        zertifikatHandle: EricZertifikatHandle,
        pin: *const byteChar,
        base64Eingabe: *const byteChar,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Alle Einstellungen werden auf den jeweiligen Standardwert zurck gesetzt.\n\n Die Standardwerte sind im Dokument ERiC-Entwicklerhandbuch.pdf, Kap. \"Vorbelegung der ERiC-Einstellungen\"\n zu finden.\n\n\n @return\n    -    ::ERIC_OK\n    -    ::ERIC_GLOBAL_UNKNOWN\n    -    ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungLesen()\n      - EricEinstellungZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungAlleZuruecksetzen() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der Wert der API-Einstellung @c name wird im @c rueckgabePuffer zurck geliefert.\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n @param[out] rueckgabePuffer Handle auf einen Rckgabepuffer, in den\n            der Wert der API-Einstellung geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungZuruecksetzen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungLesen(
        name: *const ::std::os::raw::c_char,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die API-Einstellung @c name wird auf den @c wert gesetzt.\n\n Nach dem Laden der ERiC-Bibliotheken hat jede API-Einstellung\n ihren Standardwert. Mit dieser Funktion kann der Wert\n verndert werden. Der Wertebereich der jeweiligen API-Einstellung\n ist zu beachten.\n\n Bei Pfad-Einstellungen muss auf Windows der Wert in der fr Datei-Funktionen\n benutzten ANSI-Codepage, auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale\n und auf macOS in der \"decomposed form\" von UTF-8 bergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Fr Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"bergabe von Pfaden an ERiC API-Funktionen\"\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n @param[in] wert Wert der API-Einstellung, NULL-terminierte Zeichenfolge.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_EINSTELLUNG_WERT_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungLesen()\n      - EricEinstellungZuruecksetzen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungSetzen(
        name: *const ::std::os::raw::c_char,
        wert: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der Wert der API-Einstellung @c name wird auf den Standardwert zurck gesetzt.\n\n Die Standardwerte sind im Dokument ERiC-Entwicklerhandbuch.pdf,\n Kap. \"Vorbelegung der ERiC-Einstellungen\" zu finden.\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungLesen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungZuruecksetzen(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Alle verwendeten Plugin-Bibliotheken werden entladen und deren Speicher wird freigegeben.\n\n Der ERiC ldt die fr die Bearbeitung notwendigen Plugin-Bibliotheken permanent\n in den Speicher und gibt diese erst mit dem Aufruf dieser Funktion wieder frei.\n \\n Falls eine Plugin-Bibliothek nicht entladen werden kann,\n wird dies in eric.log protokolliert. Der Returncode ist immer ::ERIC_OK.\n\n @note\n       Wenn die Steuersoftware darauf angewiesen ist, den ERiC erfolgreich\n       und komplett zu entladen, muss zuvor EricEntladePlugins() aufgerufen werden.\n\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n - ERiC-Entwicklerhandbuch.pdf, Kap. \"Verwendung von EricEntladePlugins()\""]
    pub fn EricEntladePlugins() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Konvertiert ein Einheitswert-Aktenzeichen im ELSTER-Format in ein landesspezifisches Bescheidformat\n\n Konvertiert ein Einheitswert-Aktenzeichen im ELSTER-Format (z.B. 2831400190001250002)\n in ein landesspezifisches Einheitswert-Aktenzeichen im Bescheidformat (z.B. 3100190001250002).\n\n @param[in] ewAzElster\n            Zeiger auf ein Einheitswert-Aktenzeichen im ELSTER-Format  (z.B. 2831400190001250002)\n\n @param[out] ewAzBescheidPuffer Handle auf einen Rckgabepuffer, in den\n            das Einheitswert-Aktenzeichen im Bescheidformat (z.B. 3100190001250002) geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n"]
    pub fn EricFormatEWAz(
        ewAzElster: *const byteChar,
        ewAzBescheidPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Steuernummer @c eingabeSteuernummer wird in das Bescheid-Format des jeweiligen Bundeslandes umgewandelt.\n\n @param[in] eingabeSteuernummer\n            Gltige, zu formatierende Steuernummer im\n            ELSTER-Steuernummernformat.\n @param[out] rueckgabePuffer Handle auf einen Rckgabepuffer, in den\n            die formatierte Steuernummer im Bescheid-Format des\n            jeweiligen Bundeslandes geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n     - ::ERIC_OK\n     - ::ERIC_GLOBAL_NULL_PARAMETER\n     - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n     - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n     - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n     - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n     - Pruefung_der_Steuer_und_Steueridentifikatsnummer.pdf"]
    pub fn EricFormatStNr(
        eingabeSteuernummer: *const byteChar,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Auswahlliste(n) fr @c datenartVersion oder @c feldkennung wird zurck geliefert.\n\n Anwendungsflle:\n 1. Parameter @c feldkennung ist nicht NULL: Die Funktion liefert die zur @c feldkennung und @c datenartVersion gehrige Auswahlliste.\n 2. Parameter @c feldkennung ist NULL: Die Funktion liefert alle zur @c datenartVersion gehrigen Feldkennungen mit hinterlegten Auswahllisten.\n\n Fr die Ermittlung der Auswahllisten vieler Feldkennungen wird aus Performanzgrnden Anwendungsfall 2 empfohlen.\n Die Funktion liefert Auswahllisten zu Feldkennungen vom Format \"NichtAbgeschlosseneEnumeration\" zurck.\n Diese Auswahllisten werden auch in der Jahres-/Deltadokumentation dokumentiert.\n\n @param[in] datenartVersion\n            Dieser Parameter darf nicht NULL sein.\n            Die gltigen Datenartversionen sind in Dokumentation\\Datenartversionmatrix.xml enthalten.\n @param[in] feldkennung\n            Feldkennung, fr welche die Auswahlliste zu ermitteln ist.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            die angeforderten Auswahlliste(n) als XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition in Dokumentation\\API-Rueckgabe-Schemata\\EricGetAuswahlListen.xsd.\n            \\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricGetAuswahlListen xmlns=\"http://www.elster.de/EricXML/1.0/EricGetAuswahlListen\">\n     <AuswahlListe>\n         <Feldkennung>0104110</Feldkennung>\n         <ListenElement>Arbeitslosengeld</ListenElement>\n         <ListenElement>Elterngeld</ListenElement>\n         <ListenElement>Insolvenzgeld</ListenElement>\n         <ListenElement>Krankengeld</ListenElement>\n         <ListenElement>Mutterschaftsgeld</ListenElement>\n     </AuswahlListe>\n </EricGetAuswahlListen>\n \\endcode\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_KEINE_DATEN_VORHANDEN\n         - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricGetAuswahlListen(
        datenartVersion: *const ::std::os::raw::c_char,
        feldkennung: *const ::std::os::raw::c_char,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Aus dem Antwort-XML des Finanzamtservers wird das Transferticket und Returncodes/Fehlermeldungen zurckgegeben.\n\n Die Funktion liefert bei erfolgreicher Ausfhrung:\n - Das Transferticket aus dem Antwort-XML in dem Parameter @c transferticketPuffer.\n - Den Returncode und die Fehlermeldung aus dem Transferheader\n in den Parametern @c returncodeTHPuffer und @c fehlertextTHPuffer.\n - Fr jeden Nutzdatenheader dessen Returncode und Fehlermeldung als XML-Daten im\n Parameter @c returncodesUndFehlertexteNDHXmlPuffer nach XML Schema Definition\n Dokumentation\\API-Rueckgabe-Schemata\\EricGetErrormessagesFromXMLAnswer.xsd.\n Enthlt das Antwort-XML keine Nutzdaten, wird kein \\<Fehler\\> Element zurckgegeben.\n\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] xml\n            Antwort-XML des ELSTER-Servers, das ausgewertet\n            werden soll. Der originale XML-Server-Datenstrom\n            sollte unverndert bergeben werden und darf\n            insbesondere keine Zeilenumbruchzeichen enthalten.\n @param[out] transferticketPuffer Handle auf einen Rckgabepuffer, in den\n            das Transferticket geschrieben wird, siehe ::EricRueckgabepufferHandle.\n @param[out] returncodeTHPuffer Handle auf einen Rckgabepuffer, in den\n            der Returncode aus dem Transferheader geschrieben wird.\n            Siehe ::EricRueckgabepufferHandle.\n @param[out] fehlertextTHPuffer Handle auf einen Rckgabepuffer, in den\n            die Fehlermeldung aus dem Transferheader geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n @param[out] returncodesUndFehlertexteNDHXmlPuffer Handle auf einen\n            Rckgabepuffer, in den die Liste der Returncodes nach XML-Schema\n            Dokumentation\\API-Rueckgabe-Schemata\\EricGetErrormessagesFromXMLAnswer.xsd\n            geschrieben werden, siehe ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricGetErrormessagesFromXMLAnswer xmlns=\"http://www.elster.de/EricXML/1.0/EricGetErrormessagesFromXMLAnswer\">\n     <Fehler>\n       <Code>1</Code>\n       <Meldung>Fehlermeldung 1</Meldung>\n     </Fehler>\n     <Fehler>\n       <Code>2</Code>\n       <Meldung>Fehlermeldung 2</Meldung>\n     </Fehler>\n     (...)\n </EricGetErrormessagesFromXMLAnswer>\n \\endcode\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_IO_PARSE_FEHLER\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_PUFFER_ZUGRIFFSKONFLIKT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n\n @note\n - Diese Funktion kann nicht dafr verwendet werden, die Antwort im Datenteil\n   aus einer dekodierten Serverantwort fr Lohnsteuerbescheinigungen\n   auszuwerten.\n\n @see\n      - XML-Schema des Transferheaders: Dokumentation\\Schnittstellenbeschreibungen\\ElsterBasisSchema\\Schema\\th000011_extern.xsd\n      - XML-Schema des Nutzdatenheaders: Dokumentation\\Schnittstellenbeschreibungen\\ElsterBasisSchema\\Schema\\ndh000011.xsd\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Schnittstellenbeschreibungen\",\n        Tabelle \"Ergnzende Softwarepakete und Dateien  Schnittstellenbeschreibungen\""]
    pub fn EricGetErrormessagesFromXMLAnswer(
        xml: *const ::std::os::raw::c_char,
        transferticketPuffer: EricRueckgabepufferHandle,
        returncodeTHPuffer: EricRueckgabepufferHandle,
        fehlertextTHPuffer: EricRueckgabepufferHandle,
        returncodesUndFehlertexteNDHXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fr das bergebene Zertifikat in @c pathToKeystore wird das Handle @c hToken\n        und die untersttzten PIN-Werte @c iInfoPinSupport zurckgeliefert.\n\n Die ERiC API bentigt Zertifikat-Handles typischerweise\n bei kryptografischen Operationen.\n \\n Zertifikat-Handles sollten mglichst frhzeitig, d.h. wenn sie nicht\n mehr bentigt werden, mit EricCloseHandleToCertificate() freigegeben\n werden, sptestens jedoch zum Programmende bzw. vor dem Entladen der\n ericapi Bibliothek.\n\n @param[out] hToken Handle zu einem der folgenden Zertifikate:\n                      - Portalzertifikat\n                      - clientseitig erzeugtes Zertifikat\n                      - Ad Hoc-Zertifikat fr den neuen Personalausweis\n @param[out] iInfoPinSupport\n            Wird in @c iInfoPinSupport ein Zeiger ungleich NULL bergeben und die Funktion mit ::ERIC_OK beendet,\n            dann enthlt @c iInfoPinSupport einen vorzeichenlosen Integer-Wert.\n            In diesem Wert ist kodiert abgelegt, ob eine PIN-Eingabe\n            erforderlich ist und welche PIN-Statusinformationen\n            untersttzt werden.\n            Die kodierten Werte (nachfolgend in hexadezimaler Form angegeben)\n            knnen durch ein binres ODER kombiniert werden und bedeuten im\n            Einzelnen:\n            - 0x00: Keine PIN-Angabe erforderlich, kein PIN-Status untersttzt.\n            - 0x01: PIN-Angabe fr Signatur erforderlich.\n            - 0x02: PIN-Angabe fr Entschlsselung erforderlich.\n            - 0x04: PIN-Angabe fr Verschlsselung des Zertifikats erforderlich.\n            - 0x08: reserviert (wird derzeit nicht verwendet)\n            - 0x10: PIN-Status \"Pin Ok\" wird untersttzt.\n            - 0x20: PIN-Status \"Der letzte Versuch der Pin-Eingabe schlug fehl\" wird untersttzt.\n            - 0x40: PIN-Status \"Beim nchsten fehlerhaften Versuch wird die Pin gesperrt\" wird untersttzt.\n            - 0x80: PIN-Status \"Pin ist gesperrt\" wird untersttzt.\n            \\n Falls vom Aufrufer NULL bergeben wird, gibt die Funktion nichts zurck.\n @param[in] pathToKeystore\n            1. Clientseitig erzeugtes Zertifikat: <br>\n              Pfad zum Verzeichnis, in dem sich die Zertifikats-Datei (.cer)\n              und die Datei mit dem privaten Schlssel (.p12) befinden.\n              Diese Kryptomittel wurden mit EricCreateKey() erzeugt.\n              Der Pfad zum Verzeichnis ist bei clientseitig erzeugten\n              Zertifikaten relativ zum aktuellen Arbeitsverzeichnis oder absolut\n              anzugeben.\n            2. Software-Portalzertifikat: <br>\n              Pfad zur Software-Zertifikatsdatei (i.d.R. mit der Endung .pfx).\n              Der Pfad zur Datei ist bei Software-Zertifikaten relativ zum\n              aktuellen Arbeitsverzeichnis oder absolut anzugeben.\n            3. Sicherheitsstick: <br>\n              Pfad zur Treiberdatei, siehe (1). Bitte beachten, dass der Treiber\n              betriebssystemabhngig sein kann. Weitere Informationen in der\n              Anleitung zum Sicherheitsstick oder unter\n              https://www.sicherheitsstick.de .\n            4. Signaturkarte: <br>\n              Pfad zur Treiberdatei, welcher einen Zugriff auf die\n              Signaturkarte ermglicht, siehe (1). Weitere Informationen in\n              der Anleitung zur Signaturkarte.\n            5. Neuer Personalausweis (nPA): <br>\n              URL des eID-Clients wie zum Beispiel der AusweisApp 2\n              In den meisten Fllen lautet diese URL: http://127.0.0.1:24727/eID-Client\n              Optional kann auf die folgende Weise noch ein Testmerker angehngt werden:\n              http://127.0.0.1:24727/eID-Client?testmerker=520000000\n              Zu den verfgbaren Testmerkern siehe ERiC-Entwicklerhandbuch.pdf,\n              Kap. \"Test Untersttzung bei der ERiC-Anbindung\".\n              \\n\\b Wichtig: Das Ad Hoc-Zertifikat, das in diesem Fall fr den neuen\n                       Personalausweis erzeugt wird, ist nur 24 Stunden gltig.\n\n            (1) Bei Sicherheitssticks und Signaturkarten ist bei der Angabe\n            des Treibers der Suchmechanismus nach dynamischen Modulen des\n            jeweiligen Betriebssystems zu bercksichtigen. Weitere\n            Informationen sind z.B. unter Windows der Dokumentation der\n            LoadLibrary() oder unter Linux und macOS der Dokumentation der\n            dlopen() zu entnehmen.\n\n            Pfade mssen auf Windows in der fr Datei-Funktionen benutzten ANSI-Codepage,\n            auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale\n            und auf macOS in der \"decomposed form\" von UTF-8 bergeben werden.\n            Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n            Pfaden und Pfadtrennzeichen beachten.\n            Fr Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n            \"bergabe von Pfaden an ERiC API-Funktionen\"\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n         - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n         - ::ERIC_CRYPT_E_MAX_SESSION\n         - ::ERIC_CRYPT_E_PSE_PATH\n         - ::ERIC_CRYPT_E_BUSY\n         - ::ERIC_CRYPT_E_P11_SLOT_EMPTY\n         - ::ERIC_CRYPT_E_NO_SIG_ENC_KEY\n         - ::ERIC_CRYPT_E_LOAD_DLL\n         - ::ERIC_CRYPT_E_NO_SERVICE\n         - ::ERIC_CRYPT_E_ESICL_EXCEPTION\n \\n\\n <b>Nur bei Verwendung des neuen Personalausweises:</b>\n         - ::ERIC_TRANSFER_EID_CLIENTFEHLER\n         - ::ERIC_TRANSFER_EID_FEHLENDEFELDER\n         - ::ERIC_TRANSFER_EID_IDENTIFIKATIONABGEBROCHEN\n         - ::ERIC_TRANSFER_EID_NPABLOCKIERT\n         - ::ERIC_TRANSFER_EID_IDNRNICHTEINDEUTIG\n         - ::ERIC_TRANSFER_EID_KEINCLIENT\n         - ::ERIC_TRANSFER_EID_KEINKONTO\n         - ::ERIC_TRANSFER_EID_SERVERFEHLER\n         - ::ERIC_TRANSFER_ERR_CONNECTSERVER\n         - ::ERIC_TRANSFER_ERR_NORESPONSE\n         - ::ERIC_TRANSFER_ERR_PROXYAUTH\n         - ::ERIC_TRANSFER_ERR_PROXYCONNECT\n         - ::ERIC_TRANSFER_ERR_SEND\n         - ::ERIC_TRANSFER_ERR_SEND_INIT\n         - ::ERIC_TRANSFER_ERR_TIMEOUT\n\n @see\n         - EricCloseHandleToCertificate()\n         - EricGetPinStatus()"]
    pub fn EricGetHandleToCertificate(
        hToken: *mut EricZertifikatHandle,
        iInfoPinSupport: *mut u32,
        pathToKeystore: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der PIN-Status wird fr ein passwortgeschtztes Kryptomittel abgefragt und in @c pinStatus zurckgegeben.\n\n Der PIN-Status wird fr einen passwortgeschtzten Bereich\n ermittelt, der durch das bergebene Zertifikat-Handle im\n Parameter @c hToken referenziert wird. Da bei Sicherheitssticks\n und Signaturkarten durch ein einziges Zertifikat-Handle zwei\n Schlsselpaare referenziert werden knnen (eines fr die\n Signatur und eines fr die Verschlsselung von Daten),\n muss grundstzlich der Parameter @c keyType gesetzt werden.\n \\n Mit dem Rckgabewert der Funktion kann der Endanwender\n rechtzeitig informiert werden, falls bei einer weiteren\n falschen PIN-Eingabe das Kryptomittel gesperrt wird. Im\n Fehlerfall ist @c pinStatus nicht definiert.\n \\n Der Karten- bzw. Stickhersteller ist verantwortlich,\n dass seine Implementierung den korrekten PIN-Status\n zurckgibt, siehe auch\n Tabelle \"PIN-Statusabfrage fr POZ\" im Unterkap.\n \"Das Portalzertifikat (POZ)\" im Dokument\n ERiC-Entwicklerhandbuch.pdf.\n\n @param[in] hToken\n            Zertifikat-Handle fr dessen passwortgeschtzten\n            Bereich der PIN-Status ermittelt werden soll.\n            Wird von der Funktion\n            EricGetHandleToCertificate() zurckgeliefert.\n @param[out] pinStatus\n            Mgliche Rckgabewerte:\n            - 0: StatusPinOk: Kein Fehlversuch oder keine\n                 Informationen verfgbar\n            - 1: StatusPinLocked: PIN gesperrt\n            - 2: StatusPreviousPinError: Die letzte\n                 PIN-Eingabe war fehlerhaft\n            - 3: StatusLockedIfPinError: Beim nchsten\n                 fehlerhaften Versuch wird die PIN gesperrt\n @param[in] keyType\n            Mgliche Eingabewerte:\n            - 0: eSignatureKey: Schlssel fr die Signatur\n                 von Daten\n            - 1: eEncryptionKey: Schlssel fr die\n                 Verschlsselung von Daten\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - weitere, siehe eric_fehlercodes.h\n\n @see\n     - EricGetHandleToCertificate()\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zertifikate und Authentifizierungsverfahren\"\n"]
    pub fn EricGetPinStatus(
        hToken: EricZertifikatHandle,
        pinStatus: *mut u32,
        keyType: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird der ffentliche Schlssel als base64-kodierte Zeichenkette\n        fr das bergebene Zertifikat in @c cryptoParameter zurckgeliefert.\n\n @param[in] cryptoParameter\n            Die Struktur enthlt das Zertifikat-Handle und die PIN. Der Abrufcode wird ignoriert.\n            Falls der Zugriff auf den ffentlichen Schlssel keine PIN erfordert,\n            ist PIN=NULL anzugeben.\n @param[out] rueckgabePuffer\n            Handle auf den Rckgabepuffer. Bei Erfolg enthlt\n            der Rckgabepuffer den ffentlichen Schlssel als base64-kodierte Zeichenkette.\n            \\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_CRYPT_E_INVALID_HANDLE\n         - ::ERIC_CRYPT_E_P12_ENC_KEY\n         - ::ERIC_CRYPT_E_PIN_WRONG\n         - ::ERIC_CRYPT_E_PIN_LOCKED\n         - weitere, siehe eric_fehlercodes.h\n"]
    pub fn EricGetPublicKey(
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Es wird die Klartextfehlermeldung zu dem @c fehlerkode ermittelt.\n\n Die Funktion liefert die Klartextfehlermeldung zu einem\n ERiC Fehlercode - definiert in eric_fehlercodes.h\n\n\n @param[in] fehlerkode\n            Eingabe-Fehlercode, definiert in eric_fehlercodes.h.\n @param[out] rueckgabePuffer Handle auf einen Rckgabepuffer, in den\n            die Klartextfehlermeldung geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle. \\n\n            Die Klartextfehlermeldung ist gem UTF-8 kodiert. \\n\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_FEHLERMELDUNG_NICHT_VORHANDEN\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFehlerText(
        fehlerkode: ::std::os::raw::c_int,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird die Finanzamtliste fr eine bestimmte @c finanzamtLandNummer zurckgegeben.\n\n @param[in] finanzamtLandNummer\n              Die Finanzamtlandnummer besteht aus den ersten zwei Stellen der\n              Bundesfinanzamtsnummer. Eine Liste aller Finanzamtlandnummern wird\n              von ::EricHoleFinanzamtLandNummern() zurckgegeben.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzaemter.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleFinanzaemter xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleFinanzaemter\">\n     <Finanzamt>\n       <BuFaNummer>2801</BuFaNummer>\n       <Name>Finanzamt Offenburg Auenstelle Achern</Name>\n     </Finanzamt>\n     <Finanzamt>\n       <BuFaNummer>2804</BuFaNummer>\n       <Name>Finanzamt Villingen-Schwenningen Auenstelle Donaueschingen</Name>\n     </Finanzamt>\n     (...)\n </EricHoleFinanzaemter>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_UTI_COUNTRY_NOT_SUPPORTED\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFinanzaemter(
        finanzamtLandNummer: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Liste aller Finanzamtlandnummern wird zurckgegeben.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzamtLandNummern.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleFinanzamtLandNummern xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleFinanzamtLandNummern\">\n     <FinanzamtLand>\n       <FinanzamtLandNummer>28</FinanzamtLandNummer>\n       <Name>Baden-Wrttemberg</Name>\n     </FinanzamtLand>\n     <FinanzamtLand>\n       <FinanzamtLandNummer>91</FinanzamtLandNummer>\n       <Name>Bayern (Zustndigkeit LfSt - Mnchen)</Name>\n     </FinanzamtLand>\n     (...)\n </EricHoleFinanzamtLandNummern>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFinanzamtLandNummern(
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c finanzamtsdaten werden fr eine Bundesfinanzamtsnummer zurckgegeben.\n\n Die Bundesfinanzamtsnummer kann ber die Kombination der Funktionen ::EricHoleFinanzamtLandNummern()\n und ::EricHoleFinanzaemter() ermittelt werden.\n\n @param[in] bufaNr\n            bergabe der 4-stelligen Bundesfinanzamtsnummer.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzamtsdaten.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c bufaNr ist NULL.\n        - ::ERIC_GLOBAL_PRUEF_FEHLER: Die bergebene Bundesfinanzamtsnummer ist keine Ganzzahl.\n        - ::ERIC_GLOBAL_KEINE_DATEN_VORHANDEN: Immer bei Testfinanzmtern.\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n    - ::EricHoleFinanzamtLandNummern()\n    - ::EricHoleFinanzaemter()"]
    pub fn EricHoleFinanzamtsdaten(
        bufaNr: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Testfinanzamtliste wird in @c rueckgabeXmlPuffer zurckgegeben.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleTestFinanzaemter.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleTestFinanzaemter xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleTestFinanzaemter\">\n   <Finanzamt>\n       <BuFaNummer>1096</BuFaNummer>\n       <Name>Testfinanzamt Saarland</Name>\n     </Finanzamt>\n     <Finanzamt>\n       <BuFaNummer>1097</BuFaNummer>\n       <Name>Finanzschule (Edenkoben)</Name>\n     </Finanzamt>\n     (...)\n </EricHoleTestFinanzaemter>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleTestfinanzaemter(
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Eigenschaften des bergebenen Zertifikats werden im @c rueckgabeXmlPuffer zurckgegeben.\n\n @param[in] hToken Handle des Zertifikats, dessen Eigenschaften geholt werden sollen.\n            Wird von der Funktion EricGetHandleToCertificate() zurckgeliefert.\n @param[in] pin PIN zum ffnen des Zertifikats. Wird bei Software-Portalzertifikaten\n            bentigt.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den die Zertifikateigenschaften\n             im XML-Format geschrieben werden. Das Format ist im XML Schema\n             Dokumentation\\API-Rueckgabe-Schemata\\EricHoleZertifikatEigenschaften.xsd\n             definiert.\n             Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n @note       Bei einem ELSTER-Softwarezertifikat (.pfx) steht im Common Name (CN) die ID des ELSTER-Kontos,\n             fr das das Zertifikat ausgestellt wurde.\n             Die Konto-ID kann beispielsweise dafr genutzt werden, bei einer Zertifikatsverlngerung\n             das verlngerte Zertifikat dem alten Zertifikat zuzuordnen.\n\n \\b Beispiel:\n \\code\n <EricHoleZertifikatEigenschaften xmlns=\"http://www.elster.de/EricXML/2.0/EricHoleZertifikatEigenschaften\">\n   <Signaturzertifikateigenschaften>\n       <AusgestelltAm>220817152116Z</AusgestelltAm>\n       <GueltigBis>230817152116Z</GueltigBis>\n       <Signaturalgorithmus>sha1WithRSAEncryption(1.2.840.113549.1.1.5)</Signaturalgorithmus>\n       <PublicKeyMD5>6b8b191936677957fe74103198e77f4e</PublicKeyMD5>\n       <PublicKeySHA1>884b0dfe2e10221a2aedd28c986cf34db0f1d932</PublicKeySHA1>\n       <PublicKeyBitLength>2048</PublicKeyBitLength>\n       <Issuer>\n           <Info><Name>CN</Name><Wert>ElsterSoftCA</Wert></Info>\n           <Info><Name>OU</Name><Wert>CA</Wert></Info>\n           (...)\n       </Issuer>\n       <Subjekt>\n           <Info><Name>CN</Name><Wert>1000872896</Wert></Info>\n       </Subjekt>\n       <Identifikationsmerkmaltyp>Steuernummer</Identifikationsmerkmaltyp>\n       <Registrierertyp>Person</Registrierertyp>\n       <Verifikationsart>Postweg</Verifikationsart>\n       <TokenTyp>Software</TokenTyp>\n       <Testzertifikat>true</Testzertifikat>\n   </Signaturzertifikateigenschaften>\n   <Verschluesselungszertifikateigenschaften>\n       (...)\n   </Verschluesselungszertifikateigenschaften>\n </EricHoleZertifikatEigenschaften>\n \\endcode\n\n @return\n      - ::ERIC_OK\n      - ::ERIC_GLOBAL_NULL_PARAMETER\n      - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n      - ::ERIC_GLOBAL_UNKNOWN\n      - ERIC_CRYPT_E_*: Ein Zertifikatsfehler aus dem Statuscodebereich\n                        von ::ERIC_CRYPT_E_INVALID_HANDLE = 610201101 bis 610201212\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Verwendung von EricHoleZertifikatEigenschaften()\"\n      - Dokumentation\\API-Rueckgabe-Schemata\\EricHoleZertifikatEigenschaften.xsd\n"]
    pub fn EricHoleZertifikatEigenschaften(
        hToken: EricZertifikatHandle,
        pin: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Der Fingerabdruck und dessen Signatur wird fr das bergebene\n         Zertifikat zurckgegeben.\n\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] cryptoParameter Zertifikatsdaten,\n            siehe eric_verschluesselungs_parameter_t.\n            Das in der bergebenen Struktur referenzierte Zertifikat muss\n            ein clientseitig erzeugtes Zertifikat (CEZ) sein.\n @param[out] fingerabdruckPuffer Handle auf einen Rckgabepuffer, in\n            den der Fingerabdruck geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n @param[out] signaturPuffer Handle auf einen Rckgabepuffer, in den\n            die Signatur des Fingerabdrucks geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n\n @note Die Erzeugung eines Fingerabdrucks mit dieser Funktion ist nur\n       in Zusammenhang mit clientseitig erzeugten Zertifikaten definiert.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_PUFFER_ZUGRIFFSKONFLIKT\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n - ::ERIC_CRYPT_E_P12_READ\n - ::ERIC_CRYPT_E_P12_DECODE\n - ::ERIC_CRYPT_E_PIN_WRONG\n - ::ERIC_CRYPT_E_P12_SIG_KEY\n - ::ERIC_CRYPT_E_P12_ENC_KEY\n - ::ERIC_CRYPT_ZERTIFIKAT\n - ::ERIC_CRYPT_EIDKARTE_NICHT_UNTERSTUETZT\n - ::ERIC_CRYPT_SIGNATUR\n - ::ERIC_CRYPT_CORRUPTED"]
    pub fn EricHoleZertifikatFingerabdruck(
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        fingerabdruckPuffer: EricRueckgabepufferHandle,
        signaturPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialisiert den Singlethreading-ERiC\n\n Vor der Verwendung der Singlethreading-API muss ::EricInitialisiere()\n aufgerufen werden.\n\n Mehrfache Aufrufe dieser Funktion, ohne das zwischendurch\n ::EricBeende() aufgerufen worden ist, fhren dazu, dass der\n Fehlercode ::ERIC_GLOBAL_MEHRFACHE_INITIALISIERUNG zurckgegeben\n wird. Der zuvor initialisierte Singlethreading-ERiC bleibt davon\n aber unberhrt und ist weiterhin in einem gltigen Zustand.\n\n @param[in] pluginPfad Pfad, in dem die Plugins rekursiv gesucht werden.\n                       Ist der Zeiger gleich \\c NULL, wird der Pfad zur\n                       Bibliothek ericapi verwendet.\n @param[in] logPfad Optionaler Pfad zur Log-Datei eric.log. Ist der\n                    Wert gleich \\c NULL, wird das betriebssystemspezifische\n                    Verzeichnis fr temporre Dateien verwendet.\n\n @note Kann kein eric.log angelegt werden, wird eine entsprechende\n       Fehlermeldung auf die Konsole (stderr) geschrieben und an den\n       Windows-Ereignisdienst bzw. den syslogd-Dienst (Linux, AIX, macOS)\n       geschickt.\n       Fr Linux, AIX und macOS ist zu beachten, dass der syslogd-Dienst\n       gegebenenfalls erst noch zu aktivieren und fr die Protokollierung\n       von Meldungen der Facility \"User\" zu konfigurieren ist.\n       Suchkriterien fr ERiC-Meldungen in der Windows-Ereignisansicht\n       sind \"ERiC (Elster Rich Client)\" als Quelle und \"Anwendung\"\n       als Protokoll.\n       Suchkriterien fr ERiC-Meldungen in den Systemlogdateien\n       unter Linux, AIX und macOS sind die Facility \"User\" und\n       der Ident \"ERiC (Elster Rich Client)\".\n\n @return\n             - ::ERIC_OK\n             - ::ERIC_GLOBAL_MEHRFACHE_INITIALISIERUNG\n             - ::ERIC_GLOBAL_FEHLER_INITIALISIERUNG\n             - ::ERIC_GLOBAL_LOG_EXCEPTION\n\n @see\n      - ::EricBeende()"]
    pub fn EricInitialisiere(
        pluginPfad: *const byteChar,
        logPfad: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird eine Steuernummer im ELSTER-Steuernummerformat erzeugt.\n\n Die Funktion erzeugt aus einer angegebenen Steuernummer\n im Format des Steuerbescheides eine 13-stellige\n Steuernummer im ELSTER-Steuernummerformat.<br>\n\n Die sich ergebende 13-stellige Steuernummer im\n ELSTER-Steuernummerformat wird von der Funktion\n ::EricMakeElsterStnr() auch auf Gltigkeit geprft.<br>\n\n Einer der beiden Parameter @c landesnr oder @c bundesfinanzamtsnr muss\n korrekt angegeben werden. Der jeweils andere Parameter darf NULL oder leer\n sein. Bei bayerischen und berliner Steuernummern im Format BBB/UUUUP ist die\n Angabe der Bundesfinanzamtsnummer zwingend erforderlich.\n\n @param[in]  steuernrBescheid\n             Format der Steuernummer wie auch auf amtlichen\n             Schreiben angegeben.\n @param[in]  landesnr\n             2-stellige Landesnummer (entspricht den ersten\n             zwei Stellen der Bundesfinanzamtsnummer).\n @param[in]  bundesfinanzamtsnr\n             4-stellige Bundesfinanzamtsnummer.\n @param[out] steuernrPuffer Handle auf einen Rckgabepuffer, in den\n             die Steuernummer im ELSTER-Steuernummerformat geschrieben wird.\n             Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_LANDESNUMMER_UNBEKANNT\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricMakeElsterStnr(
        steuernrBescheid: *const byteChar,
        landesnr: *const byteChar,
        bundesfinanzamtsnr: *const byteChar,
        steuernrPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Konvertiert ein Einheitswert-Aktenzeichen in das ELSTER-Format\n\n Konvertiert ein gltiges Einheitswert-Aktenzeichen in einem landesspezifischen Bescheidformat (z.B. 208/035-3-03889.3)\n unter Angabe des Landeskrzels in ein Einheitswert-Aktenzeichen im ELSTER-Format (z.B. 520840353038893).\n\n @param[in] ewAzBescheid\n            Zeiger auf das Einheitswert-Aktenzeichen in einem landesspezifischen Bescheidformat.\n @param[in] landeskuerzel\n            Zeiger auf das Landeskrzel (zum Beispiel BY fr Bayern)\n @param[out] ewAzElsterPuffer Handle auf einen Rckgabepuffer, in den\n             das erzeugte Einheitswert-Aktenzeichen im ELSTER-Format geschrieben wird.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n  - ::ERIC_GLOBAL_EWAZ_LANDESKUERZEL_UNBEKANNT\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n     - Landeskrzel siehe ISO-3166-2"]
    pub fn EricMakeElsterEWAz(
        ewAzBescheid: *const byteChar,
        landeskuerzel: *const byteChar,
        ewAzElsterPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c bic wird auf Gltigkeit berprft.\n\n Die Prfung erfolgt in zwei Schritten:\n\n -# Formale Prfung auf gltige Zeichen und richtige Lnge.\n -# Prfung, ob das Lnderkennzeichen fr BIC gltig ist.\n\n Falls die BIC ungltig ist liefert die Funktion EricHoleFehlerText()\n den zugehrigen Fehlertext.\n\n @param[in] bic Zeiger auf eine NULL-terminierte Zeichenkette.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_BIC_FORMALER_FEHLER: Ungltige Zeichen, falsche Lnge.\n  - ::ERIC_GLOBAL_BIC_LAENDERCODE_FEHLER\n  - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c bic ist NULL.\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"BIC ISO-Lndercodes\"\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"BIC-Prfung\""]
    pub fn EricPruefeBIC(bic: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c iban wird auf Gltigkeit berprft.\n\n Die Prfung erfolgt in vier Schritten:\n\n -# Formale Prfung auf gltige Zeichen und richtige Lnge.\n -# Prfung, ob das Lnderkennzeichen fr IBAN gltig ist.\n -# Prfung, ob das lnderspezifische Format gltig ist.\n -# Prfung, ob die Prfziffer der IBAN gltig ist.\n\n Falls die IBAN ungltig ist liefert die Funktion EricHoleFehlerText()\n den zugehrigen Fehlertext.\n\n @param[in] iban Zeiger auf eine NULL-terminierte Zeichenkette.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_IBAN_FORMALER_FEHLER: Ungltige Zeichen, falsche Lnge.\n  - ::ERIC_GLOBAL_IBAN_LAENDERCODE_FEHLER\n  - ::ERIC_GLOBAL_IBAN_LANDESFORMAT_FEHLER\n  - ::ERIC_GLOBAL_IBAN_PRUEFZIFFER_FEHLER\n  - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c iban ist NULL.\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"IBAN - lnderspezifische Formate\"\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"IBAN-Prfung\"\n"]
    pub fn EricPruefeIBAN(iban: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief berprft ein @c Einheitswert-Aktenzeichen im ELSTER-Format auf Gltigkeit.\n\n @param[in] einheitswertAz\n            Zeiger auf ein Einheitswert-Aktenzeichen im ELSTER-Format\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n"]
    pub fn EricPruefeEWAz(einheitswertAz: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c steuerId wird auf Gltigkeit berprft.\n\n @param[in] steuerId\n            Steuer-Identifikationsnummer (IdNr)\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_IDNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricPruefeSteuernummer()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Prfung der Steueridentifikationsnummer (IdNr)\"\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Test-Steueridentifikationsnummer\""]
    pub fn EricPruefeIdentifikationsMerkmal(steuerId: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c steuernummer wird einschlielich Bundesfinanzamtsnummer\n        auf formale Richtigkeit geprft.\n\n Zur Prfung der Bundesfinanzamtsnummer wird\n ::EricPruefeBuFaNummer() verwendet.\n\n Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] steuernummer NULL-terminierte 13-stellige Steuernummer im\n            ELSTER-Steuernummernformat.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricPruefeBuFaNummer()\n         - Pruefung_der_Steuer-_und_Steueridentifikatsnummer.pdf"]
    pub fn EricPruefeSteuernummer(steuernummer: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Prft, ob die @c pin zum Zertifikat @c pathToKeystore passt.\n        Nicht anwendbar auf Ad Hoc-Zertifikate (AHZ), die fr einen\n        neuen Personalausweis (nPA) ausgestellt sind.\n\n @param[in] pathToKeystore\n            Folgende Zertifikatstypen werden untersttzt:\n            1. Clientseitig erzeugtes Zertifikat: <br>\n              Pfad zum Verzeichnis, in dem sich die Zertifikats-Datei (.cer)\n              und die Datei mit dem privaten Schlssel (.p12) befinden.\n              Diese Kryptomittel wurden mit EricCreateKey() erzeugt.\n              Der Pfad zum Verzeichnis ist bei clientseitig erzeugten\n              Zertifikaten relativ zum aktuellen Arbeitsverzeichnis oder absolut\n              anzugeben.\n            2. Software-Portalzertifikat: <br>\n              Pfad zur Software-Zertifikatsdatei (i.d.R. mit der Endung .pfx).\n              Der Pfad zur Datei ist bei Software-Zertifikaten relativ zum\n              aktuellen Arbeitsverzeichnis oder absolut anzugeben.\n            3. Sicherheitsstick: <br>\n              Pfad zur Treiberdatei, siehe (2). Bitte beachten, dass der Treiber\n              betriebssystemabhngig sein kann. Weitere Informationen in der\n              Anleitung zum Sicherheitsstick oder unter\n              https://www.sicherheitsstick.de .\n            4. Signaturkarte: <br>\n              Pfad zur Treiberdatei, welcher einen Zugriff auf die\n              Signaturkarte ermglicht, siehe (2). Weitere Informationen in\n              der Anleitung zur Signaturkarte.\n @param[in] pin\n            PIN fr den Zugriff auf den privaten Schlssel des Zertifikats.\n @param[in] keyType\n            Mgliche Eingabewerte:\n            - 0: eSignatureKey: Schlssel fr die Signatur von Daten, siehe (1).\n            - 1: eEncryptionKey: Schlssel fr die Verschlsselung von Daten, siehe (1).\n\n  (1) Bei einem Zertifikat wie dem mit EricCreateKey() clientseitig\n  erzeugten Zertifikat (CEZ), das nur einen einzigen, gemeinsamen Schlssel\n  fr Signatur und Verschlsselung besitzt, sind beide Eingabewerte\n  erlaubt. Die Werte beziehen sich dann beide auf denselben Schlssel.\n\n  (2) Bei Sicherheitssticks und Signaturkarten ist bei der Angabe\n  des Treibers der Suchmechanismus nach dynamischen Modulen des\n  jeweiligen Betriebssystems zu bercksichtigen. Weitere\n  Informationen sind z.B. unter Windows der Dokumentation der\n  LoadLibrary() oder unter Linux und macOS der Dokumentation der\n  dlopen() zu entnehmen.\n\n  Pfade mssen auf Windows in der fr Datei-Funktionen benutzten ANSI-Codepage,\n  auf Linux, AIX und Linux Power in der fr das Dateisystem benutzten Locale\n  und auf macOS in der \"decomposed form\" von UTF-8 bergeben werden.\n  Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n  Pfaden und Pfadtrennzeichen beachten.\n  Fr Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n  \"bergabe von Pfaden an ERiC API-Funktionen\".\n\n  Es wird empfohlen, geffnete Zertifikatshandle zu schlieen, bevor mit\n  der API-Funktion EricPruefeZertifikatPin() das gewnschte Zertifikat geprft wird.\n\n  @note Eine falsche PIN-Eingabe erhht bei Sicherheitsstick und Signaturkarte den\n        Zhler fr Fehlversuche. Welche Zertifikatstypen aufgrund von 3 Fehlversuchen\n        gesperrt werden, ist im ERiC-Entwicklerhandbuch.pdf Kap.\n        \"Das Portalzertifikat (POZ)\" beschrieben.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_CRYPT_E_PIN_WRONG\n  - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n  - ::ERIC_CRYPT_EIDKARTE_NICHT_UNTERSTUETZT\n  - ::ERIC_CRYPT_E_PSE_PATH\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricPruefeZertifikatPin(
        pathToKeystore: *const byteChar,
        pin: *const byteChar,
        keyType: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c funktion wird als Callback-Funktion fr\n        ::EricBearbeiteVorgang() registriert.\n\n Die registrierte Callback-Funktion wird von der Funktion\n ::EricBearbeiteVorgang() aufgerufen, um bei der Verarbeitung\n den Fortschritt der einzelnen Arbeitsbereiche anzuzeigen.\n\n @param funktion      Zeiger auf die zu registrierende Funktion oder \\c NULL.\n @param benutzerdaten Zeiger, der der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      bergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereFortschrittCallback() mit dem\n           Wert \\c NULL im Parameter \\c funktion aufzurufen.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgefhrt werden.\n\n @see\n         - EricFortschrittCallback\n         - EricBearbeiteVorgang()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Funktionen fr Fortschrittcallbacks\"\n"]
    pub fn EricRegistriereFortschrittCallback(
        funktion: EricFortschrittCallback,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die registrierte @c funktion wird als Callback-Funktion\n        von ::EricBearbeiteVorgang() aufgerufen und zeigt den\n        Gesamtfortschritt der Verarbeitung an.\n\n @param funktion      Zeiger auf die zu registrierende Funktion oder \\c NULL.\n @param benutzerdaten Zeiger, der der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      bergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereGlobalenFortschrittCallback()\n           mit dem Wert \\c NULL im Parameter \\c funktion aufzurufen.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer\n           Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgefhrt werden.\n\n @see\n         - EricBearbeiteVorgang()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Funktionen fr Fortschrittcallbacks\""]
    pub fn EricRegistriereGlobalenFortschrittCallback(
        funktion: EricFortschrittCallback,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die registrierte @c funktion wird als Callback-Funktion fr\n        jede Lognachricht aufgerufen.\n        Die Ausgabe entspricht einer Zeile im eric.log.\n\n @param funktion Zeiger auf die zu registrierende Funktion oder NULL.\n @param schreibeEricLogDatei\n          - \\c 1  Jede Log-Nachricht wird nach eric.log geschrieben.\n                  Der Parameter \\c funktion kann auf eine\n                  Funktion zeigen oder \\c NULL sein.\n          - \\c 0  Falls \\c funktion \\c != \\c NULL werden keine Log-Nachrichten\n                  nach eric.log geschrieben, andernfalls werden die\n                  Log-Nachrichten nach eric.log geschrieben.\n @param benutzerdaten Zeiger, welcher der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      bergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereLogCallback() mit dem Wert\n           \\c NULL im Parameter \\c funktion aufzurufen (=Deregistrierung).\n         - Vor dem Beenden der Steueranwendung ist eine registrierte\n           Funktion zu deregistrieren, da es sonst zu einem Absturz\n           kommen kann.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer\n           Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgefhrt werden.\n"]
    pub fn EricRegistriereLogCallback(
        funktion: EricLogCallback,
        schreibeEricLogDatei: u32,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Diese API-Funktion erzeugt einen Rckgabepuffer und gibt\n        ein Handle darauf zurck.\n\n Die von dieser Funktion erzeugten Rckgabepuffer werden verwendet, um\n die Ausgaben von ERiC-Funktionen (z.B. EricBearbeiteVorgang())\n aufzunehmen. Dazu wird das Rckgabepuffer-Handle fr den Schreibvorgang\n an die ausgebende Funktion bergeben.<br>\n Zum Auslesen des von den API-Funktionen beschriebenen Puffers wird das\n Rckgabepuffer-Handle an EricRueckgabepufferInhalt() bergeben.\n Ein einmal erzeugtes Rckgabepuffer-Handle kann fr weitere nachfolgende\n Aufrufe von ERiC API-Funktionen wiederverwendet werden. Bei einer\n Wiederverwendung eines Handles werden frhere Inhalte berschrieben.\n Nach Verwendung muss jeder Rckgabepuffer mit\n EricRueckgabepufferFreigeben() freigegeben werden.\n Rckgabepuffer sind der Singlethreading-API bzw. einer ERiC-Instanz der\n Multithreading-API fest zugeordnet. Die Funktionen der ERiC API, die\n einen Rckgabepuffer entgegen nehmen, geben den Fehlercode\n ::ERIC_GLOBAL_PUFFER_UNGLEICHER_INSTANZ zurck, wenn der bergebene\n Rckgabepuffer\n      - mit der Singlethreading-API erzeugt worden ist und dann mit der\n        Multithreading-API verwendet wird\n      - mit der Multithreading-API erzeugt worden ist und dann mit der\n        Singlethreading-API verwendet wird\n      - mit einer ERiC-Instanz erzeugt worden ist und dann mit einer\n        anderen Instanz verwendet wird.\n\n\n @return\n         - ::EricRueckgabepufferHandle im Erfolgsfall.\n         - NULL im Fehlerfall.\n\n @see\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferInhalt()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferErzeugen() -> EricRueckgabepufferHandle;
}
extern "C" {
    #[doc = " @brief Der durch das @c handle bezeichnete Rckgabepuffer wird\n        freigegeben.\n\n Das Handle darf danach nicht weiter verwendet werden. Es wird daher\n empfohlen, Handle-Variablen nach der Freigabe explizit auf\n NULL zu setzen.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen().\n            angelegten Rckgabepuffer. Dieser Rckgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferInhalt()"]
    pub fn EricRueckgabepufferFreigeben(handle: EricRueckgabepufferHandle)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der durch das @c handle bezeichnete Inhalt des Rckgabepuffers wird zurckgegeben.\n\n Der zurckgegebene Zeiger verweist auf ein Byte-Array, das alle in\n den Rckgabepuffer geschriebenen Bytes sowie eine abschlieende\n NULL-Terminierung enthlt. Dieses Array existiert so lange im Speicher,\n bis der Rckgabepuffer entweder (bei einer Wiederverwendung des Handles)\n erneut beschrieben oder der Puffer explizit freigegeben wird.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen().\n            angelegten Rckgabepuffer. Dieser Rckgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n         - Zeiger auf den NULL-terminierten Rckgabepufferinhalt, wenn ein gltiges Handle bergeben wird.\n         - NULL: Bei bergabe des ungltigen Handles NULL.\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferInhalt(
        handle: EricRueckgabepufferHandle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Die Lnge des Rckgabepufferinhalts wird zurckgegeben.\n\n Die zurckgegebene Zahl entspricht der Anzahl von Bytes, die von einer\n zuvor aufgerufenen ERiC API-Funktion in den Rckgabepuffer geschrieben\n wurden.\n Die NULL-Terminierung, die bei Aufruf von EricRueckgabepufferInhalt() an\n das zurckgegebene Byte-Array angefgt wird, wird bei dieser\n Lngenangabe nicht bercksichtigt.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen()\n            angelegten Rckgabepuffer. Dieser Rckgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n         - Anzahl der in den Rckgabepuffer geschriebenen Bytes, wenn ein gltiges Handle bergeben wird.\n         - 0: Bei bergabe des ungltigen Handles NULL.\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferInhalt()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferLaenge(handle: EricRueckgabepufferHandle) -> u32;
}
extern "C" {
    #[doc = " @brief Es werden Plattform-, Betriebssystem- und\n        ERiC-Informationen ausgegeben.\n\n Diese Funktion liefert Informationen ber die\n verwendeten ERiC-Bibliotheken, ERiC-Druckvorlagen,\n die eingesetzte Plattform, den Arbeitsspeicher und\n das verwendete Betriebssystem.\n\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - weitere, siehe eric_fehlercodes.h\n\n @see\n      - EricVersion()"]
    pub fn EricSystemCheck() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird eine Liste smtlicher Produkt- und Dateiversionen\n        der verwendeten ERiC-Bibliotheken als XML-Daten zurckgegeben.\n\n Diese Funktion kann bei auftretenden Fehlern die\n Fehlersuche beschleunigen und Supportflle untersttzen.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rckgabepuffer, in den\n            zu allen ERiC-Bibliotheken die Produkt- und Dateiversionen\n            als XML-Daten nach XML Schema Definition Dokumentation\\API-Rueckgabe-Schemata\\EricVersion.xsd\n            geschrieben werden. Zur Erzeugung, Verwendung und Freigabe von Rckgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricVersion xmlns=\"http://www.elster.de/EricXML/1.0/EricVersion\">\n     <Bibliothek>\n       <Name>ericapi.dll</Name>\n       <Produktversion>99, 1, 2, 32767</Produktversion>\n       <Dateiversion>2008, 3, 5, 0</Dateiversion>\n     </Bibliothek>\n     <Bibliothek>\n       <Name>ericctrl.dll</Name>\n       <Produktversion>99, 1, 2, 32767</Produktversion>\n       <Dateiversion>2008, 3, 5, 0</Dateiversion>\n     </Bibliothek>\n     (...)\n </EricVersion>\n \\endcode\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - weitere, siehe eric_fehlercodes.h\n\n @see\n      - EricSystemCheck()"]
    pub fn EricVersion(rueckgabeXmlPuffer: EricRueckgabepufferHandle) -> ::std::os::raw::c_int;
}
