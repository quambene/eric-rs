/* automatically generated by rust-bindgen 0.69.4 */

pub const PLATFORM_NAME: &[u8; 13] = b"Linux/x86-64\0";
pub const LINUX: u32 = 1;
pub const ERIC_UINT32_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ERIC_STDINT_VORHANDEN: u32 = 1;
pub const HAS_FUTIME: u32 = 0;
pub const UTIME_NEEDS_CLOSED_FILE: u32 = 1;
pub const _UTIME_H: u32 = 1;
pub const ERIC_MAX_LAENGE_FUSSTEXT: u32 = 30;
pub const ERIC_TESTMERKER_CLEARINGSTELLE: &[u8; 10] = b"700000004\0";
pub const ERIC_TESTMERKER_ECC: &[u8; 10] = b"700000001\0";
pub type BYTE = ::std::os::raw::c_uchar;
pub type byte = ::std::os::raw::c_uchar;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    pub actime: __time_t,
    pub modtime: __time_t,
}
#[test]
fn bindgen_test_layout_utimbuf() {
    const UNINIT: ::std::mem::MaybeUninit<utimbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<utimbuf>(),
        16usize,
        concat!("Size of: ", stringify!(utimbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<utimbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(utimbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(actime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modtime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(utimbuf),
            "::",
            stringify!(modtime)
        )
    );
}
extern "C" {
    pub fn utime(
        __file: *const ::std::os::raw::c_char,
        __file_times: *const utimbuf,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EricInstanz {
    _unused: [u8; 0],
}
#[doc = " @brief Handle auf eine ERiC-Instanz.\n\n ERiC-Instanzen werden von der Multithreading-API angelegt,\n verwendet und wieder freigegeben, siehe ericmtapi.h.\n \\n Alle API-Funktionen der Multithreading-API nehmen einen Zeiger auf eine\n ERiC-Instanz entgegen und verrichten ihre Aufgaben auf dieser ERiC-Instanz.\n Die EricInstanz enthält sämtliche veränderlichen Zustände des ERiC.\n Dies sind ERiC-Einstellungen, Plugin- und Log-Verzeichnis, Proxyeinstellungen,\n Zertifikatshandle, Rückgabepuffer, etc.\n \\n Es können mehrere ERiC-Instanzen parallel angelegt werden. Jede dieser\n ERiC-Instanzen ist unabhängig von allen anderen ERiC-Instanzen. Verfügen\n mehrere Threads jeweils über ihre eigene ERiC-Instanz, können sie diese\n parallel verwenden. Dazu müssen die Threads den API-Funktionen der\n Multithreading-API ihre jeweils eigene ERiC-Instanz übergeben.\n \\n ERiC-Instanzen sollen nicht für jede Aufgabe neu erstellt und konfiguriert\n werden. Das Erstellen und Zerstören einer ERiC-Instanz ist ressourcen- und zeitintensiv.\n Die Lebenszeit einer ERiC-Instanz sollte beispielsweise eher der Lebenszeit\n eines Arbeiter-Threads in einem Pool entsprechen, als der Verarbeitungsdauer\n einer einzelnen Aufgabe an einen Arbeiter-Thread.\n \\n ERiC-Instanzen können zwischen Threads ausgetauscht werden. Eine\n ERiC-Instanz darf aber nicht in zwei Threads gleichzeitig verwendet werden.\n\n @see\n       - ::EricMtInstanzErzeugen()\n       - ::EricMtInstanzFreigeben()"]
pub type EricInstanzHandle = *mut EricInstanz;
#[doc = " @brief Der Datentyp byteChar wird immer dann verwendet, wenn an diesem Parameter\n        keine UTF-8 codierte Daten erwartet werden.\n        Diese Daten werden ungeprüft verwendet.\n        <b>Zum Beispiel:</b> Pfade"]
pub type byteChar = ::std::os::raw::c_char;
#[doc = " @brief Integer-Typ für Zertifikat-Handles."]
pub type EricZertifikatHandle = u32;
#[doc = " @brief Das ::EricTransferHandle wird beim Anwendungsfall \"Datenabholung\"\n        der API-Funktion ::EricBearbeiteVorgang() übergeben.\n\n Es ist vom Aufrufer zu initialisieren\n und wird ::EricBearbeiteVorgang() als Zeiger übergeben. Es wird\n verwendet, um bei der Datenabholung mehrere Versandvorgänge zu bündeln.\n Dabei ist das Handle für den ersten Vorgang \"Anfrage\" mit dem Wert 0\n zu intialisieren bevor ::EricBearbeiteVorgang() aufgerufen wird.\n Das von ::EricBearbeiteVorgang() zurückgegebene Handle ist dann\n bei allen Folgevorgängen derselben Datenabholung unverändert\n wieder zu übergeben.\n \\n Wird bei einer Datenabholung NULL oder ein ungültiger Zeiger\n als Handle übergeben, gibt ::EricBearbeiteVorgang()\n den Fehlercode ::ERIC_GLOBAL_TRANSFERHANDLE zurück.\n \\n Bei allen Verfahren außer der Datenabholung sollte das Transferhandle\n beim Aufruf der ::EricBearbeiteVorgang() NULL sein. Wird bei solchen\n Verfahren ein Handle übergeben, so wird dieses ignoriert.\n"]
pub type EricTransferHandle = u32;
#[doc = " @brief Der Datensatz soll validiert werden."]
pub const eric_bearbeitung_flag_t_ERIC_VALIDIERE: eric_bearbeitung_flag_t = 2;
#[doc = " @brief Der Datensatz soll an den ELSTER Annahmeserver versendet werden."]
pub const eric_bearbeitung_flag_t_ERIC_SENDE: eric_bearbeitung_flag_t = 4;
#[doc = " @brief Der Datensatz soll gedruckt werden."]
pub const eric_bearbeitung_flag_t_ERIC_DRUCKE: eric_bearbeitung_flag_t = 32;
#[doc = " @brief Der Datensatz soll auf Hinweise hin geprüft werden."]
pub const eric_bearbeitung_flag_t_ERIC_PRUEFE_HINWEISE: eric_bearbeitung_flag_t = 128;
#[doc = " @brief Bearbeitungsflags für die Anwendungsfälle von EricBearbeiteVorgang().\n\n Welche Anwendungsfälle von der jeweiligen Datenart unterstützt werden,\n ist dem ERiC-Entwicklerhandbuch.pdf zu entnehmen."]
pub type eric_bearbeitung_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EricReturnBufferApi {
    _unused: [u8; 0],
}
#[doc = " @brief Handle zur Verwaltung und Verwendung von Rückgabepuffern.\n\n Viele ERiC API-Funktionen geben Informationen an ihren Aufrufer zurück,\n indem sie Daten in sogenannte Rückgabepuffer schreiben.\n Solche Rückgabepuffer müssen mit ::EricRueckgabepufferErzeugen() angelegt\n werden. Das bei dieser Erzeugung generierte Puffer-Handle wird vom Aufrufer\n an die API-Funktion übergeben, die den Puffer leert bevor sie dann in den\n Puffer schreibt. Ein einmal generiertes Puffer-Handle kann damit auch für\n mehrere aufeinanderfolgende Aufrufe von ERiC API-Funktionen wiederverwendet\n werden.\n Mittels ::EricRueckgabepufferLaenge() kann danach die Anzahl der in den\n Puffer geschriebenen Bytes ermittelt werden.\n Mit ::EricRueckgabepufferInhalt() kann der Pufferinhalt abgefragt werden.\n Jeder Rückgabepuffer muss nach seiner Verwendung mit\n ::EricRueckgabepufferFreigeben() wieder freigegeben werden.\n\n Die Struktur EricReturnBufferApi kapselt die Rückgabepuffer-Implementierung.\n Anwender der ERiC API verwenden ausschließlich Zeiger auf Instanzen dieser\n Struktur und müssen daher deren Felder nicht kennen.\n\n Rückgabepuffer sind der Singlethreading-API bzw. einer ERiC-Instanz der\n Multithreading-API fest zugeordnet. Die Funktionen der ERiC API, die einen\n Rückgabepuffer entgegen nehmen, geben den Fehlercode\n ::ERIC_GLOBAL_PUFFER_UNGLEICHER_INSTANZ zurück, wenn der übergebene\n Rückgabepuffer\n      - mit der Singlethreading-API erzeugt worden ist und dann mit der\n        Multithreading-API verwendet wird\n      - mit der Multithreading-API erzeugt worden ist und dann mit der\n        Singlethreading-API verwendet wird\n      - mit einer ERiC-Instanz erzeugt worden ist und dann mit einer\n        anderen Instanz verwendet wird.\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf Kap. \"Rückgabepuffer der ERiC Programmierschnittstelle\"\n      - ::EricRueckgabepufferErzeugen()\n      - ::EricRueckgabepufferLaenge()\n      - ::EricRueckgabepufferInhalt()\n      - ::EricRueckgabepufferFreigeben()"]
pub type EricRueckgabepufferHandle = *mut EricReturnBufferApi;
#[doc = " @brief Diese Struktur enthält alle für den Druck notwendigen Informationen.\n\n Der Anwendungsentwickler muss diese Struktur allokieren und nach Verwendung\n wieder freigeben.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_druck_parameter_t {
    #[doc = " @brief Version dieser Struktur. Die Version muss derzeit immer 2 sein.\n        Bei Änderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 2 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Soll ein Vorschau-PDF erstellt werden?\n\n - vorschau = 1: Ein Vorschau-PDF wird erzeugt und als solches gekennzeichnet.\n - vorschau = 0: Es wird kein Vorschau-PDF erzeugt.\n\n @note Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub vorschau: u32,
    #[doc = " @brief Soll das PDF nur die erste Seite oder alles enthalten?\n\n - ersteSeite = 1: Es wird nur die erste Seite einer komprimierten Erklärung gedruckt.\n - ersteSeite = 0: Es wird alles gedruckt.\n\n @note\n       - Fachliche Informationen sind im ERiC-Entwicklerhandbuch.pdf nachzulesen.\n       - Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben."]
    pub ersteSeite: u32,
    #[doc = " @brief Soll die PDF-Datei für einen doppelseitigen Ausdruck mit Heftrand zum Lochen vorbereitet werden?\n\n - duplexDruck = 1: Die geraden Seiten werden für einen Heftrand zum Lochen nach links eingerückt, Details siehe ERiC-Entwicklerhandbuch.pdf\n - duplexDruck = 0: Es erfolgt keine Einrückung der geraden Seiten. Das erstellte PDF ist nur zum blattweisen Ausdruck der Seiten vorgesehen.\n\n @note Bei Werten ungleich 0 oder 1 wird #ERIC_GLOBAL_UNGUELTIGER_PARAMETER zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben."]
    pub duplexDruck: u32,
    #[doc = " @brief Pfad der erzeugten PDF-Datei.\n\n Pfade müssen auf Windows in der für Dateifunktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 übergeben werden.\n Weiterführende Informationen hierzu, sowie zu nicht erlaubten Zeichen in\n Pfaden und Pfadtrennzeichen, relative Pfadangabe, etc. siehe\n Entwicklerhandbuch Kapitel \"Übergabe von Pfaden an ERiC API-Funktionen\".\n\n <b>Windows-Beispiel:</b> \"c:\\\\test\\\\ericprint.pdf\"\n\n Soll eine PDF-Datei angelegt werden, ist der pdfName zwingend erforderlich\n\n <B> Besonderheiten bei Sammeldaten </B>\n Für Sammeldaten wird dem PDF-Dateinamen vor der Dateiendung das Nutzdatenticket\n angefügt:\n \\n <PDF-Dateiname>_<Nutzdatenticket>.pdf\n Optional kann der PDF-Dateiname den Platzhalter \"%t\" enthalten, der dann\n durch das Nutzdatenticket ersetzt wird:\n \\n \"%t_ericprint.pdf\" --> \"<Nutzdatenticket>_ericprint.pdf\"\n\n @note Es ist sicherzustellen, dass alle PDF-Dateien im Dateisystem\n erstellt bzw. geschrieben werden können.  Falls es beim Erstellen der\n PDF-Dokumente einen Fehler gibt oder falls diese nicht geschrieben\n werden können, wird die Bearbeitung abgebrochen, eine Log-Ausgabe\n erstellt, aus der hervorgeht, welcher Steuerfall nicht gedruckt werden\n konnte, und eine Fehlermeldung an den Aufrufer zurückgeliefert."]
    pub pdfName: *const byteChar,
    #[doc = " @brief Fußtext der auf dem Ausdruck verwendet werden soll (optional).\n @details Wenn der übergebene Text länger als #ERIC_MAX_LAENGE_FUSSTEXT\n Zeichen ist, dann bricht der Druck mit Fehlerkode\n #ERIC_PRINT_FUSSTEXT_ZU_LANG ab!\n\n @note Fachliche Informationen sind im ERiC-Entwicklerhandbuch.pdf nachzulesen."]
    pub fussText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_druck_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_druck_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_druck_parameter_t>(),
        32usize,
        concat!("Size of: ", stringify!(eric_druck_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_druck_parameter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(eric_druck_parameter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vorschau) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(vorschau)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ersteSeite) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(ersteSeite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duplexDruck) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(duplexDruck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdfName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(pdfName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fussText) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_druck_parameter_t),
            "::",
            stringify!(fussText)
        )
    );
}
#[doc = " @brief Für die Signatur oder Authentifizierung benötigte\n Informationen.\n\n Diese Struktur ist vom Anwender zu allokieren und samt\n Inhalt auch wieder freizugeben."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_verschluesselungs_parameter_t {
    #[doc = " @brief Version dieser Struktur. Muss derzeit immer 2 sein.\n        Bei Änderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 2 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Verweis auf den KeyStore, siehe EricGetHandleToCertificate()."]
    pub zertifikatHandle: EricZertifikatHandle,
    #[doc = " @brief PIN für den KeyStore."]
    pub pin: *const ::std::os::raw::c_char,
    #[doc = " @brief Dieser muss für Datenlieferungen zum Verfahren\nElsterDatenabholung und Datenart ElsterVaStDaten\nangegeben werden, falls für die Signatur ein\nSoftPSE-Zertifikat verwendet wird. In allen anderen Fällen\nmuss hier NULL übergeben werden. Der Parameter abrufCode\nbesteht aus 2 x 5 Zeichen, die mit \"-\" verbunden sind.\n\\b Beispiel: \"K6FG5-RS32P\""]
    pub abrufCode: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_verschluesselungs_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_verschluesselungs_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_verschluesselungs_parameter_t>(),
        24usize,
        concat!("Size of: ", stringify!(eric_verschluesselungs_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_verschluesselungs_parameter_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eric_verschluesselungs_parameter_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zertifikatHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(zertifikatHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abrufCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_verschluesselungs_parameter_t),
            "::",
            stringify!(abrufCode)
        )
    );
}
#[doc = " @brief Struktur mit Informationen zur Erzeugung von Zertifikaten mit #EricCreateKey.\n\n Die Elemente der Struktur beschreiben den Anwender, für den ein Schlüssel erstellt werden soll.\n Unbenutzte Parameter müssen mit NULL oder Leerstring initialisiert werden.\n\n Diese Struktur und ihre Elemente sind vom Anwender zu allokieren und samt Inhalt auch wieder freizugeben.\n Alle Elemente sind vom Anwender zu initialisieren.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eric_zertifikat_parameter_t {
    #[doc = " @brief Version dieser Struktur. Muss derzeit immer 1 sein.\n        Bei Änderungen dieser Struktur wird dieser Wert inkrementiert.\n\n @note Bei einem Wert ungleich 1 wird #ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION zurückgegeben und eine Fehlermeldung in die Logdatei geschrieben.\n"]
    pub version: u32,
    #[doc = " @brief Name des Anwenders.\n\n Die Angabe des Namens ist obligatorisch.\n Der Parameter darf nicht mit NULL oder einem Leerstring belegt werden."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " @brief Land (Länderkürzel) des Anwenders. \\b Beispiel: \"DE\".\n\n Die Angabe dieses Wertes ist optional."]
    pub land: *const ::std::os::raw::c_char,
    #[doc = " @brief Wohnort des Anwenders, inklusive PLZ. \\b Beispiel: \"D-10179 Berlin\".\n\n Die Angabe dieses Wertes ist optional."]
    pub ort: *const ::std::os::raw::c_char,
    #[doc = " @brief Straßenangabe mit Hausnummer des Anwenders mit Zusätzen, \\b Beispiel: \"Musterstraße 123 Zugang im Rückgebäude\".\n\n Die Angabe dieses Wertes ist optional."]
    pub adresse: *const ::std::os::raw::c_char,
    #[doc = " @brief E-Mail-Adresse des Anwenders.\n\n Die Angabe dieses Wertes ist optional."]
    pub email: *const ::std::os::raw::c_char,
    #[doc = " @brief Name der Organisation.\n\n Die Angabe dieses Wertes ist optional.\n Wenn \\c organisation und \\c abteilung nicht angegeben werden, wird \"ELSTER\" verwendet."]
    pub organisation: *const ::std::os::raw::c_char,
    #[doc = " @brief Name der Abteilung (organizational unit) der Organisation.\n\n Die Angabe dieses Wertes ist optional.\n Wenn \\c organisation und \\c abteilung nicht angegeben werden, wird \"ERiC\" verwendet."]
    pub abteilung: *const ::std::os::raw::c_char,
    #[doc = " @brief Beschreibung, welche für den Anwender im Zertifikat abgelegt wird.\n\n Die Angabe dieses Wertes ist optional."]
    pub beschreibung: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_eric_zertifikat_parameter_t() {
    const UNINIT: ::std::mem::MaybeUninit<eric_zertifikat_parameter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<eric_zertifikat_parameter_t>(),
        72usize,
        concat!("Size of: ", stringify!(eric_zertifikat_parameter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<eric_zertifikat_parameter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(eric_zertifikat_parameter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).land) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(land)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ort) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(ort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adresse) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(adresse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).email) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).organisation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(organisation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abteilung) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(abteilung)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beschreibung) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eric_zertifikat_parameter_t),
            "::",
            stringify!(beschreibung)
        )
    );
}
#[doc = " Fehler, der zum Programmabbruch führt."]
pub const eric_log_level_t_ERIC_LOG_ERROR: eric_log_level_t = 4;
#[doc = " Hinweise auf Zustände, die zu Fehlern führen können."]
pub const eric_log_level_t_ERIC_LOG_WARN: eric_log_level_t = 3;
#[doc = " Grobe Informationen über den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_INFO: eric_log_level_t = 2;
#[doc = " Feingranulare Informationen über den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_DEBUG: eric_log_level_t = 1;
#[doc = " Sehr feingranulare Informationen über den Programmablauf und Werte."]
pub const eric_log_level_t_ERIC_LOG_TRACE: eric_log_level_t = 0;
#[doc = " ::eric_log_level_t ist ein Parameter für Funktionen vom Typ ::EricLogCallback.\n Der Loglevel kann zum Filtern für das ERiC Protokoll verwendet werden, siehe\n ERiC-Entwicklerhandbuch.pdf Kap. \"Das ERiC Protokoll eric.log\"."]
pub type eric_log_level_t = ::std::os::raw::c_uint;
#[doc = " @brief Typ der Callback-Funktion zum Logging.\n\n Wenn registriert, wird diese Callback-Funktion\n für jeden Log-Eintrag mit folgenden Parametern aufgerufen.\n\n @param kategorie Kategorie des Logeintrags. Beinhaltet das Modul, welches\n                  den Log-Eintrag ausgibt. Zum Beispiel \"eric.ctrl2\". Kann\n                  zum Filtern verwendet werden. Alle Log-Nachrichten besitzen\n                  eine Kategorie. Der Zeiger ist nur innerhalb dieser\n                  Funktion gültig.\n\n @param loglevel Log-Level des Logeintrags. Kann zum Filtern verwendet werden.\n\n @param nachricht Enthält die Log-Nachricht als Zeichenkette. Der Zeiger ist\n                  nur innerhalb dieser Funktion gültig.\n\n @param benutzerdaten Der Zeiger, der bei der Registrierung mit\n                      ::EricRegistriereLogCallback() übergeben worden ist,\n                      wird in diesem Parameter vom ERiC unverändert\n                      übergeben.\n\n @see\n      - ::EricRegistriereLogCallback()\n"]
pub type EricLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        kategorie: *const ::std::os::raw::c_char,
        loglevel: eric_log_level_t,
        nachricht: *const ::std::os::raw::c_char,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " @brief \\c id, die beim Einlesen des XMLs von Fortschrittcallbacks\n        ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_EINLESEN: _bindgen_ty_1 = 10;
#[doc = " @brief \\c id, die gemeldet wird, wenn die Daten zum Versand noch\n        vorbereitet werden müssen."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_VORBEREITEN: _bindgen_ty_1 = 20;
#[doc = " @brief \\c id, die beim Validieren der Eingangsdaten von\n        Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_VALIDIEREN: _bindgen_ty_1 = 30;
#[doc = " @brief \\c id, die beim Versand der Ausgangsdaten von\n       Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_SENDEN: _bindgen_ty_1 = 40;
#[doc = " @brief \\c id, die beim Druck der Eingangsdaten von\n        Fortschrittcallbacks ausgegeben wird."]
pub const ERIC_FORTSCHRITTCALLBACK_ID_DRUCKEN: _bindgen_ty_1 = 50;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " @brief Typ der Callback-Funktionen, die am ERiC für Fortschrittanzeigen\n        registriert werden können.\n\n @param id Aktueller Verarbeitungsschritt\n\n @param pos Aktueller Fortschritt bezogen auf \\c max\n\n @param max Maximalwert des aktuellen Fortschritts \\c pos\n\n @param benutzerdaten Der Zeiger, der bei der Registrierung mit\n                      ::EricRegistriereGlobalenFortschrittCallback() oder\n                      ::EricRegistriereFortschrittCallback() übergeben\n                      worden ist, wird in diesem Parameter vom ERiC\n                      unverändert übergeben.\n\n @details Es gilt stets, dass:\n           - \\c pos größer oder gleich 0 und kleiner oder gleich \\c max ist\n           - \\c max ist immer größer als 0"]
pub type EricFortschrittCallback = ::std::option::Option<
    unsafe extern "C" fn(id: u32, pos: u32, max: u32, benutzerdaten: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Diese API-Funktion ist die zentrale Schnittstellenfunktion zur Kommunikation\n        mit dem ELSTER-Annahmeserver.\n\n Als Austauschformat wird XML verwendet, siehe Kapitel \"Datenverarbeitung mit ERiC\"\n im Entwicklerhandbuch. Dort sind die Arbeitsabläufe von Einzel- und Sammellieferung\n beschrieben.\n\n Die Funktion kann Steuerdaten plausibilisieren, an den ELSTER-Annahmeserver übertragen und\n ausdrucken, sowie Protokolle der Übertragung erzeugen. Die ProcessingFlags im Parameter\n @c bearbeitungsFlags definieren, welche der Schritte wie ausgeführt werden.\n\n Je nach Anwendungsfall können die Daten authentifiziert übertragen werden und es kann\n ein PDF-Druck der Daten erfolgen. In diesen Fällen sind die Parameter @c cryptoParameter\n und @c druckParameter entsprechend zu befüllen. Die möglichen Parameterkombinationen und\n Druckkennzeichnungen können im Entwicklerhandbuch nachgelesen werden.\n\n Sind für einen Anwendungsfall mehrere voneinander abhängige Aufrufe von\n ::EricBearbeiteVorgang() nötig, so ist der Parameter @c transferHandle zu übergeben. Dies\n ist derzeit nur für die Datenabholung der Fall.\n\n Es werden an bestimmten Punkten der Verarbeitung benutzerdefinierte Callback Funktionen\n aufgerufen. Siehe hierzu \\ref STSection_Fortschrittcallbacks.\n\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] datenpuffer\n              Enthält die zu verarbeitenden XML-Daten.\n @param[in] datenartVersion\n              Die @c datenartVersion ist der Datenartversionmatrix zu entnehmen,\n              siehe Dokumentation\\Datenartversionmatrix.xml und ERiC-Entwicklerhandbuch.pdf.\n              Dieser Parameter darf nicht NULL sein und muss zu den XML-Eingangsdaten passen.\n @param[in] bearbeitungsFlags\n              Oder-Verknüpfung von Bearbeitungsvorgaben.\n              Anhand dieser Vorgaben werden die übergebenen Daten verarbeitet.\n              Der Parameter darf nicht 0 sein, zu gültigen Werten siehe ::eric_bearbeitung_flag_t.\n              Bei welchen Anwendungsfällen welche Flags möglich oder notwendig sind,\n              ist im Entwicklerhandbuch nachzulesen.\n @param[in] druckParameter\n              Parameter, der für den PDF-Druck benötigt wird, siehe\n              ::eric_druck_parameter_t.\n              Bei welchen Anwendungsfällen der Druckparameter möglich oder notwendig ist,\n              ist im Entwicklerhandbuch nachzulesen. Soll kein PDF-Druck erfolgen,\n              so ist NULL zu übergeben.\n @param[in] cryptoParameter\n              Enthält die für den authentifizierten Versand benötigten\n              Informationen und darf nur dann übergeben werden,\n              siehe ::eric_verschluesselungs_parameter_t.\n              Erfolgt kein authentifizierter Versand, so ist NULL zu übergeben.\n @param[in,out] transferHandle\n              Bei der Datenabholung ist ein Zeiger auf ein vom Aufrufer verwaltetes\n              und anfangs mit 0 befülltes ::EricTransferHandle zu übergeben, über das die\n              zusammenhängenden Versandvorgänge einer Datenabholung gebündelt werden\n              (Bündelung der Versandvorgänge \"Anforderung\", \"Abholung\" und optional\n              \"Quittierung\").\n              Wenn bei der Datenabholung kein Versandflag gesetzt ist (nur Validierung),\n              darf dem transferHandle auch ein Nullzeiger (NULL) übergeben werden.\n              Bei allen anderen Anwendungsfällen ist immer NULL zu übergeben.\n @param[out] rueckgabeXmlPuffer\n              Handle auf einen Rückgabepuffer, in den beim Versand\n              Telenummer und Ordnungsbegriff, Hinweise oder Fehler bei der\n              Regelprüfung geschrieben werden, siehe\n              \\ref STSection_Rueckgabepuffer und ::EricRueckgabepufferHandle.\n @param[out] serverantwortXmlPuffer\n              Handle auf einen Rückgabepuffer, in den beim Versand die\n              Antwort des Empfangsservers geschrieben wird, siehe\n              \\ref STSection_Rueckgabepuffer und ::EricRueckgabepufferHandle.\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n        - ::ERIC_GLOBAL_VERSCHLUESSELUNGS_PARAMETER_NICHT_ANGEGEBEN\n        - ::ERIC_GLOBAL_PRUEF_FEHLER\n          Plausibilitätsfehler in den Eingabedaten, die Fehlermeldungen\n          werden im Rückgabepuffer @c rueckgabeXmlPuffer zurückgegeben.\n          Siehe Abschnitt \\ref STSection_Plausibilitaetsfehler.\n        - ::ERIC_GLOBAL_HINWEISE\n          Kann nur zurückgegeben werden, falls das Bearbeitungsflag\n          ::ERIC_PRUEFE_HINWEISE angegeben wurde.\n          Es wurden ausschließlich Hinweise zu den Eingabedaten gemeldet,\n          die Hinweise werden im Rückgabepuffer @c rueckgabeXmlPuffer zurückgegeben.\n          Siehe Abschnitt \\ref STSection_Hinweise.\n        - ::ERIC_GLOBAL_DATENSATZ_ZU_GROSS\n          Die maximal zulässige Größe des XML-Eingangsdatensatzes oder des zu übermittelnden,\n          komprimierten, verschlüsselten und base64-kodierten Datenteils,\n          siehe ERiC-Entwicklerhandbuch.pdf Kap. \"Größenbegrenzung der\n          Eingangsdaten\", ist überschritten.\n        - ::ERIC_TRANSFER_ERR_XML_THEADER, ::ERIC_TRANSFER_ERR_XML_NHEADER\n          Die Serverantwort enthält Fehlermeldungen. Zur Auswertung kann\n          entweder die Serverantwort selbst ausgewertet werden oder es wird\n          ::EricGetErrormessagesFromXMLAnswer() aufgerufen.\n        - ::ERIC_IO_READER_SCHEMA_VALIDIERUNGSFEHLER\n        - ::ERIC_IO_PARSE_FEHLER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - weitere, siehe eric_fehlercodes.h\n\n \\section STSection_Rueckgabepuffer Inhalt des Rückgabepuffers und des Serverantwortpuffers\n\n Der Inhalt der Pufferspeicher kann mit ::EricRueckgabepufferInhalt() abgefragt\n und ausgewertet werden. @c rueckgabeXmlPuffer gibt im \\ref STSection_Erfolgsfall oder bei\n \\ref STSection_Plausibilitaetsfehler XML-Daten nach Schema\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd zurück.\n @c serverantwortXmlPuffer gibt bei Sendevorgängen die Antwort des ELSTER-\n Annahmeservers zurück.\n\n Nach dem Aufruf der Funktion müssen programmatisch folgende Fälle aufgrund des Rückgabewerts\n unterschieden werden.\n\n \\subsection STSection_Erfolgsfall Erfolgsfall\n\n Sind alle Bearbeitungsschritte fehlerfrei durchlaufen worden, dann ist\n der Rückgabewert ::ERIC_OK und der Text im Pufferspeicher\n @c rueckgabeXmlPuffer enthält beim Versand XML-Daten mit generierter\n Telenummer und bei Neuaufnahmen den Ordnungsbegriff.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\"\n    <Erfolg>\n        <Telenummer>N55</Telenummer>\n    </Erfolg>\n </EricBearbeiteVorgang>\n \\endcode\n\n Beim Versand befindet sich zusätzlich im Pufferspeicher @c serverantwortXmlPuffer die Antwort\n des ELSTER-Annahmeservers. Bei einer Datenabholung kann diese ausgewertet werden. Details\n hierzu befinden sich im Entwicklerhandbuch.\n\n \\subsection STSection_Hinweise Hinweise\n\n Falls das Bearbeitungsflag ::ERIC_PRUEFE_HINWEISE angegeben worden ist, kann der\n Rückgabewert ::ERIC_GLOBAL_HINWEISE zurückgegeben werden.\n Der Rückgabepuffer enthält dann die gemeldeten Hinweise.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\">\n    <Hinweis>\n        <Nutzdatenticket>1075</Nutzdatenticket>\n        <Feldidentifikator>100001</Feldidentifikator>\n        <Mehrfachzeilenindex>1</Mehrfachzeilenindex>\n        <LfdNrVordruck>1</LfdNrVordruck>\n        <VordruckZeilennummer>4</VordruckZeilennummer>\n        <SemantischerIndex>PersonA</SemantischerIndex>\n        <Untersachbereich>5</Untersachbereich>\n        <RegelName>testRegelName</RegelName>\n        <FachlicheHinweisId>9995</FachlicheHinweisId>\n        <Text>Weitere Angaben können erforderlich sein</Text>\n    </Hinweis>\n </EricBearbeiteVorgang>\n \\endcode\n\n Die einzelnen Elemente sind in der Schemadefinition\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd dokumentiert.\n Wenn die Bearbeitungsflags ::ERIC_PRUEFE_HINWEISE und ::ERIC_VALIDIERE übergeben\n worden sind, wurden bei der Plausibilisierung keine Fehler gefunden. Es sind\n keine Fehler im Rückgabepuffer enthalten.\n\n \\subsection STSection_Plausibilitaetsfehler Plausibilitätsfehler\n\n Bei fehlgeschlagener Plausibilitätsprüfung ist der Rückgabewert\n ::ERIC_GLOBAL_PRUEF_FEHLER, und die Fehler werden im Rückgabepuffer\n als XML-Daten zurückgeliefert.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricBearbeiteVorgang xmlns=\"http://www.elster.de/EricXML/1.1/EricBearbeiteVorgang\">\n    <FehlerRegelpruefung>\n        <Nutzdatenticket>1075</Nutzdatenticket>\n        <Feldidentifikator>100001</Feldidentifikator>\n        <Mehrfachzeilenindex>1</Mehrfachzeilenindex>\n        <LfdNrVordruck>1</LfdNrVordruck>\n        <VordruckZeilennummer>4</VordruckZeilennummer>\n        <SemantischerIndex>PersonA</SemantischerIndex>\n        <Untersachbereich>5</Untersachbereich>\n        <RegelName>testRegelName</RegelName>\n        <FachlicheFehlerId>9995</FachlicheFehlerId>\n        <Text>Beim Ankreuzfeld muss der Wert 'X' angegeben werden.</Text>\n    </FehlerRegelpruefung>\n </EricBearbeiteVorgang>\n \\endcode\n\n Die einzelnen Elemente sind in der Schemadefinition\n Dokumentation\\API-Rueckgabe-Schemata\\EricBearbeiteVorgang.xsd dokumentiert.\n Wenn die Bearbeitungsflags ::ERIC_PRUEFE_HINWEISE und ::ERIC_VALIDIERE übergeben\n worden sind, kann der Rückgabepuffer auch Hinweise enthalten.\n\n \\subsection STSection_Serverfehlerfall Fehler in der Serverantwort\n\n Ist der Rückgabewert ::ERIC_TRANSFER_ERR_XML_THEADER oder\n ::ERIC_TRANSFER_ERR_XML_NHEADER so enthält der Serverantwortpuffer\n Fehlermeldungen. Zur Auswertung kann entweder die Serverantwort selbst\n ausgewertet werden oder es wird ::EricGetErrormessagesFromXMLAnswer() aufgerufen.\n\n \\subsection STSection_Fehler Sonstige Fehler\n\n Bei sonstigen Fehlern ist der Inhalt der Rückgabepuffer undefiniert. Um nähere\n Informationen über die Fehlerursache herauszufinden, kann ::EricHoleFehlerText() mit\n dem Rückgabewert aufgerufen werden.\n\n \\section STSection_Fortschrittcallbacks Fortschrittcallbacks\n\n Während der Verarbeitung eines Anwendungsfalls werden die durch die Funktionen\n ::EricRegistriereFortschrittCallback() und ::EricRegistriereGlobalenFortschrittCallback()\n registrierten Callbacks aufgerufen.\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Anwendungsfälle von EricBearbeiteVorgang()\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel der jeweiligen Datenart\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Datenabholung\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Größenbegrenzung der Eingangsdaten\"\n      - ERiC-Entwicklerhandbuch.pdf, Kapitel \"Funktionen für Fortschrittcallbacks\"\n      - EricHoleFehlerText()\n      - EricGetErrormessagesFromXMLAnswer()\n      - EricRegistriereFortschrittCallback()\n      - EricRegistriereGlobalenFortschrittCallback()\n"]
    pub fn EricBearbeiteVorgang(
        datenpuffer: *const ::std::os::raw::c_char,
        datenartVersion: *const ::std::os::raw::c_char,
        bearbeitungsFlags: u32,
        druckParameter: *const eric_druck_parameter_t,
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        transferHandle: *mut EricTransferHandle,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
        serverantwortXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Beendet den Singlethreading-ERiC\n\n Die Verarbeitung mit der ERiC Singlethread-API ist beendet, als letztes muss EricBeende() aufgerufen werden.\n\n @return\n          - ::ERIC_OK\n          - ::ERIC_GLOBAL_NICHT_INITIALISIERT\n          - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n          - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n          - EricInitialisiere()"]
    pub fn EricBeende() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die PIN für ein clientseitig erzeugtes Zertifikat (CEZ) wird geändert.\n\n Die Funktion ändert die bei der Funktion EricCreateKey() angegebene PIN\n und entsprechend hierfür die Prüfsumme in der Datei eric.sfv.\n Falls die Datei eric.sfv nicht vorhanden ist, wird sie, wie bei EricCreateKey(), erstellt.\n Eine PIN-Änderung von einem Portalzertifikat (POZ) ist nicht möglich.\n\n Pfade müssen auf Windows in der für Datei-Funktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 übergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Für Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"Übergabe von Pfaden an ERiC API-Funktionen\"\n\n @param[in] psePath\n            In dem angegebenen Pfad liegt das Schlüsselpaar\n            (eric_private.p12 und eric_public.cer).\n @param[in] oldPin\n            Bisherige PIN.\n @param[in] newPin\n            Neue PIN. Die Mindestlänge beträgt 4 Stellen. Zulässige\n            Zeichen sind alle ASCII-Zeichen ohne die Steuerzeichen.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n         - ::ERIC_CRYPT_PIN_STAERKE_NICHT_AUSREICHEND\n         - ::ERIC_CRYPT_PIN_ENTHAELT_UNGUELTIGE_ZEICHEN\n         - ::ERIC_CRYPT_E_PSE_PATH\n         - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n         - ::ERIC_CRYPT_ERROR_CREATE_KEY\n\n\n @see\n         - EricCreateKey()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zuordnung der API-Funktionen zur Verwendung von POZ, CEZ und AHZ\""]
    pub fn EricChangePassword(
        psePath: *const byteChar,
        oldPin: *const byteChar,
        newPin: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Bundesfinanzamtsnummer wird überprüft.\n\n Wird eine 13-stellige Steuernummer im\n ELSTER-Steuernummernformat angegeben, so wird nur die\n Bundesfinanzamtsnummer (= die ersten 4 Stellen der\n 13-stelligen Steuernummer) geprüft.\n\n Eine Prüfung der Steuernummer selbst findet nicht statt\n (hierfür EricPruefeSteuernummer() verwenden).\n\n @param[in] steuernummer\n            13-stellige Steuernummer im ELSTER Steuernummernformat bzw.\n            4-stellige Bundesfinanzamtsnummer.\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_BUFANR_UNBEKANNT:\n           Die Bundesfinanzamtsnummer ist unbekannt oder ungültig.\n         - ::ERIC_GLOBAL_NULL_PARAMETER:\n           Es wurde keine Bundesfinanzamtsnummer übergeben (Parameter ist NULL).\n         - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricPruefeSteuernummer()\n      - Pruefung_der_Steuer-_und_Steueridentifikatsnummer.pdf"]
    pub fn EricPruefeBuFaNummer(steuernummer: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Das @c xml wird gegen das Schema der @c datenartVersion validiert.\n\n Das verwendete Schema kann unter Dokumentation\\\\Schnittstellenbeschreibungen\\\\ nachgeschlagen werden.\n \\n Nicht unterstützte Datenartversionen:\n  - ElsterKMV\n  - alle Bilanz Datenartversionen\n\n @param[in]  xml\n             XML-Zeichenfolge\n @param[in]  datenartVersion\n             Die @c datenartVersion ist der Datenartversionmatrix zu entnehmen,\n             siehe Dokumentation\\Datenartversionmatrix.xml und ERiC-Entwicklerhandbuch.pdf.\n             Dieser Parameter darf nicht NULL sein und muss zu den XML-Eingangsdaten passen.\n @param[out] fehlertextPuffer Handle auf einen Rückgabepuffer, in den\n             Fehlertexte geschrieben werden.\n             Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_FUNKTION_NICHT_UNTERSTUETZT: Schemavalidierung wird für die übergebene @c datenartVersion nicht unterstützt.\n         - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n         - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_IO_READER_SCHEMA_VALIDIERUNGSFEHLER: Die Fehlerbeschreibung steht im fehlertextPuffer.\n         - ::ERIC_IO_PARSE_FEHLER: Die Fehlerbeschreibung steht im fehlertextPuffer.\n         - weitere, siehe eric_fehlercodes.h"]
    pub fn EricCheckXML(
        xml: *const ::std::os::raw::c_char,
        datenartVersion: *const ::std::os::raw::c_char,
        fehlertextPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Das Zertifikat-Handle @c hToken wird freigegeben.\n\n Diese Funktion gibt das übergebene Zertifikat-Handle frei.\n Zertifikat-Handles sollten möglichst frühzeitig, d.h. wenn sie nicht\n mehr benötigt werden, mit EricCloseHandleToCertificate() freigegeben\n werden, spätestens jedoch zum Programmende bzw. vor dem Entladen der\n ericapi Bibliothek.\n Das Ad Hoc-Zertifikat eines neuen Personalausweises sollte immer genau\n dann freigegeben werden, wenn es nicht mehr benötigt wird, jedoch spätestens\n vor Ablauf der 24 Stunden, die das Ad Hoc-Zertifikat gültig ist.\n Tritt ein Fehler auf, kann die Fehlermeldung mit EricHoleFehlerText()\n ausgelesen werden.\n\n @param[in] hToken\n            Zertifikat-Handle wie von der Funktion\n            EricGetHandleToCertificate() zurückgeliefert.\n @return\n         - ::ERIC_OK\n         - ::ERIC_CRYPT_E_INVALID_HANDLE\n         - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n \\n\\n <b>Nur bei Verwendung des neuen Personalausweises:</b>\n         - ::ERIC_TRANSFER_EID_CLIENTFEHLER\n         - ::ERIC_TRANSFER_EID_FEHLENDEFELDER\n         - ::ERIC_TRANSFER_EID_IDENTIFIKATIONABGEBROCHEN\n         - ::ERIC_TRANSFER_EID_NPABLOCKIERT\n         - ::ERIC_TRANSFER_EID_IDNRNICHTEINDEUTIG\n         - ::ERIC_TRANSFER_EID_KEINCLIENT\n         - ::ERIC_TRANSFER_EID_KEINKONTO\n         - ::ERIC_TRANSFER_EID_SERVERFEHLER\n         - ::ERIC_TRANSFER_ERR_CONNECTSERVER\n         - ::ERIC_TRANSFER_ERR_NORESPONSE\n         - ::ERIC_TRANSFER_ERR_PROXYAUTH\n         - ::ERIC_TRANSFER_ERR_PROXYCONNECT\n         - ::ERIC_TRANSFER_ERR_SEND\n         - ::ERIC_TRANSFER_ERR_SEND_INIT\n         - ::ERIC_TRANSFER_ERR_TIMEOUT\n\n @see\n         - EricGetHandleToCertificate()\n         - EricGetPinStatus()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Authentifizierung mit dem neuen Personalausweis (nPA)\""]
    pub fn EricCloseHandleToCertificate(hToken: EricZertifikatHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es werden die Kryptomittel für ein clientseitig erzeugtes\n        Zertifikat (CEZ) in einem Verzeichnis des Dateisystems\n        erstellt.\n\n Im angegebenen Verzeichnis @c pfad sind nach Ausführung\n der Funktion EricCreateKey() drei Dateien erstellt worden:\n - eric_public.cer: Enthält das Zertifikat mit den Daten aus\n   @c zertifikatInfo und darin den öffentlichen Schlüssel.\n - eric_private.p12: Enthält den privaten Schlüssel. Der\n   Zugriff ist über die @c pin geschützt.\n - eric.sfv: Enthält die Prüfsumme der Dateien\n   eric_public.cer und eric_private.p12. Die Integrität\n   dieser beiden Dateien kann damit jederzeit überprüft werden.\n\n Ein CEZ kann unter anderem für die\n Bescheiddaten-Rückübermittlung verwendet werden.\n Weitere Informationen zur Datenabholung lesen Sie bitte im\n ERiC-Entwicklerhandbuch.pdf nach.\n\n Über eine Meldung sollte der Benutzer darauf hingewiesen\n werden, dass die Generierung der Kryptomittel je nach\n Leistungsfähigkeit der verwendeten Hardware bis zu einigen Minuten\n dauern kann.\n\n @param[in] pin\n            PIN (Passwort), mit der auf den privaten Schlüssel\n            zugegriffen werden kann.\n            \\n Die Mindestlänge beträgt 4 Stellen. Zulässige\n            Zeichen sind alle ASCII-Zeichen ohne die\n            Steuerzeichen.\n @param[in] pfad\n            Pfad (1) in dem die Kryptomittel erzeugt werden sollen.\n            Das durch den angegebenen\n            Pfad bezeichnete Verzeichnis muss im Dateisystem\n            bereits existieren und beschreibbar sein.\n            Es gibt folgende Möglichkeiten:\n            - Absoluter Pfad: Empfehlung\n            - Relativer Pfad: Wird an das Arbeitsverzeichnis\n              angehängt\n            - Leere Zeichenkette: In diesem Fall wird das\n              Arbeitsverzeichnis verwendet.<br>\n @param[in] zertifikatInfo\n            Daten, die zur Identifikation des Schlüsselinhabers\n            im Zertifikat abgelegt werden.\n\n (1) Pfade müssen auf Windows in der für Datei-Funktionen benutzten ANSI-Codepage,\n auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale und auf macOS in der\n \"decomposed form\" von UTF-8 übergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Für Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"Übergabe von Pfaden an ERiC API-Funktionen\".\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_UNGUELTIGE_PARAMETER_VERSION\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n - ::ERIC_CRYPT_ZERTIFIKATSPFAD_KEIN_VERZEICHNIS\n - ::ERIC_CRYPT_ZERTIFIKATSDATEI_EXISTIERT_BEREITS\n - ::ERIC_CRYPT_PIN_STAERKE_NICHT_AUSREICHEND\n - ::ERIC_CRYPT_PIN_ENTHAELT_UNGUELTIGE_ZEICHEN\n - ::ERIC_CRYPT_ERROR_CREATE_KEY\n\n @see\n     - EricChangePassword()\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zertifikate und Authentifizierungsverfahren\"\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Übergabe von Pfaden an ERiC API-Funktionen\""]
    pub fn EricCreateKey(
        pin: *const byteChar,
        pfad: *const byteChar,
        zertifikatInfo: *const eric_zertifikat_parameter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Diese Funktion erzeugt einen TransferHeader.\n\n Dieser ist der oberste Header in der Datenstruktur.\n Er enthält Felder für die Kommunikation zwischen Server\n und Client. Es wird nur die Kombination\n NutzdatenHeader-Version \"11\" und TransferHeader-Version \"11\" unterstützt.\n\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] xml\n            XML-Datensatz, für den der TransferHeader erzeugt werden soll.\n            \\n Es kann entweder ein komplettes Elster-XML oder nur der Datenteil übergeben werden.\n            \\n ERiC nimmt bei diesem Parameter keine Konvertierung von Sonderzeichen in Entitätenreferenzen vor.\n            \\n Attribute, die in den Start-Tags der Elemente \"Elster\"\n            bzw. \"DatenTeil\" im übergebenen XML-Datensatz definiert werden, werden nicht in\n            das Rückgabe-XML übernommen.\n            \\n Namespace-Definitionen, die in den Start-Tags der Elemente \"Elster\"\n            bzw. \"DatenTeil\" im übergebenen XML-Datensatz definiert werden, führen zu einem ERIC_IO_PARSE_FEHLER.\n            \\n Im Rückgabe-XML werden im Start-Tag des Elements \"Elster\" die URI \"http://www.elster.de/elsterxml/schema/v11\" als\n            Default-Namensraum definiert. Die dem Element \"DatenTeil\"\n            untergeordneten Elemente aus dem übergebenen XML-Datensatz werden\n            unverändert übernommen.\n            \\n Der allgemeine Aufbau des Elster-XMLs wird im\n            ERiC-Entwicklerhandbuch.pdf im Kapitel \"Datenverarbeitung mit\n            ERiC\" beschrieben.\n @param[in] verfahren\n            Name des Verfahrens, z.B:\n            'ElsterAnmeldung', siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] datenart\n            Name der Datenart, z.B.:'LStB' oder 'UStVA',\n            siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] vorgang\n            Name der Übertragungsart, z.B.\n            'send-NoSig', siehe ERiC-Entwicklerhandbuch.pdf,\n            Tabelle \"Eigenschaften der Datenart\" im\n            jeweiligen Kapitel zur Datenart.\n @param[in] testmerker\n            Für eine Testübertragung muss der entsprechende Testmerker angegeben werden,\n            siehe ERiC-Entwicklerhandbuch.pdf, Kap. \"Test Unterstützung bei der\n            ERiC-Anbindung\". Falls ein Echtfall übertragen werden soll, muss der Wert NULL angegeben werden.\n @param[in] herstellerId\n            Hersteller-ID des Softwareproduktes.\n @param[in] datenLieferant\n            Der Wert entspricht dem XML-Element \"DatenLieferant\", wie es im\n            Schema des Transferheaders der ElsterBasis-XML-Schnittstelle\n            definiert ist.\n            \\n ERiC konvertiert bei diesem Parameter Sonderzeichen in Entitätenreferenzen.\n @param[in] versionClient\n            Angabe von Versionsinformation, die in der Serverantwort\n            auch zurückgegeben wird und ausgewertet werden kann.\n            Der Wert NULL entspricht \"keine Angabe von Versionsinformation\",\n            d.h. es wird kein Element VersionClient im Transferheader erzeugt.\n            \\n ERiC konvertiert bei diesem Parameter Sonderzeichen in Entitätenreferenzen.\n @param[in] publicKey\n            Öffentlicher Schlüssel für die Transportverschlüsselung beim Verfahren\n            ElsterLohn. Bei anderen Verfahren sollte NULL übergeben werden.\n            Dieser Wert kann mit dem Rückgabewert von ::EricGetPublicKey() befüllt\n            werden.\n            Der Inhalt dieses Parameters wird in das \\<TransportSchluessel>-\n            Element der Rückgabe-XML geschrieben.\n @param[out] xmlRueckgabePuffer Handle auf einen Rückgabepuffer, in den\n            das Elster-XML mit dem erzeugten TransportHeader geschrieben wird,\n            siehe ::EricRueckgabepufferHandle. Es wird immer ein vollständiger\n            Elster-XML-Datensatz mit dem \"Elster\"-Element als Wurzel-Element\n            zurückgeliefert. Bzgl. der darin enthaltenen XML-Namespace-Definitionen sind\n            die bei der Beschreibung des Parameters \"xml\" genannten Einschränkungen\n            zu berücksichtigen.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_TRANSFER_ERR_XML_ENCODING: Die übergebenen XML-Daten sind\n                  nicht UTF-8 kodiert.\n         - ::ERIC_IO_PARSE_FEHLER\n         - ::ERIC_IO_DATENTEILNOTFOUND\n         - ::ERIC_IO_DATENTEILENDNOTFOUND\n         - weitere, siehe eric_fehlercodes.h\n\n\n @see\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Datenverarbeitung mit ERiC\"\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Anwendungsfälle von EricBearbeiteVorgang()\"\n     - ERiC-Returncodes und Fehlertexte sind in eric_fehlercodes.h zu finden."]
    pub fn EricCreateTH(
        xml: *const ::std::os::raw::c_char,
        verfahren: *const ::std::os::raw::c_char,
        datenart: *const ::std::os::raw::c_char,
        vorgang: *const ::std::os::raw::c_char,
        testmerker: *const ::std::os::raw::c_char,
        herstellerId: *const ::std::os::raw::c_char,
        datenLieferant: *const ::std::os::raw::c_char,
        versionClient: *const ::std::os::raw::c_char,
        publicKey: *const byteChar,
        xmlRueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @brief Es werden die mit der Datenabholung abgeholten und verschlüsselten Daten entschlüsselt.\n\n  Falls während der Bearbeitung ein Fehler auftritt,\n  liefert die Funktion EricHoleFehlerText() den\n  dazugehörigen Fehlertext.\n\n @param[in] zertifikatHandle Handle auf das zum Entschlüsseln zu verwendende Zertifikat.\n @param[in] pin PIN zum Zugriff auf das Zertifikat.\n @param[in] base64Eingabe Base64-kodierte verschlüsselte Daten oder Anhänge, welche mit dem Verfahren\n                          ElsterDatenabholung abgeholt wurden. Die Abholdaten befinden sich im Element\n                          /Elster[1]/DatenTeil[1]/Nutzdatenblock/Nutzdaten[1]/Datenabholung[1]/Abholung[1]/Datenpaket.\n                          Die optionalen Anhänge befinden sich im Element\n                          /Elster[1]/DatenTeil[1]/Nutzdatenblock/Nutzdaten[1]/Datenabholung[1]/Abholung[1]/Anhaenge[1]/Anhang[1]/Dateiinhalt.\n @param[out] rueckgabePuffer Handle auf einen Rückgabepuffer, in den\n            die entschlüsselten Daten geschrieben werden. Im Fehlerfall ist der Inhalt des Rückgabepuffers undefiniert.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_ERR_DEKODIEREN\n  - ::ERIC_GLOBAL_UNKNOWN\n  - Ein Zertifikatsfehler aus dem Statuscodebereich von ::ERIC_CRYPT_E_INVALID_HANDLE = 610201101 bis 610201212\n\n @see\n      - EricHoleFehlerText()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Datenabholung\""]
    pub fn EricDekodiereDaten(
        zertifikatHandle: EricZertifikatHandle,
        pin: *const byteChar,
        base64Eingabe: *const byteChar,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Alle Einstellungen werden auf den jeweiligen Standardwert zurück gesetzt.\n\n Die Standardwerte sind im Dokument ERiC-Entwicklerhandbuch.pdf, Kap. \"Vorbelegung der ERiC-Einstellungen\"\n zu finden.\n\n\n @return\n    -    ::ERIC_OK\n    -    ::ERIC_GLOBAL_UNKNOWN\n    -    ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungLesen()\n      - EricEinstellungZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungAlleZuruecksetzen() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der Wert der API-Einstellung @c name wird im @c rueckgabePuffer zurück geliefert.\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n @param[out] rueckgabePuffer Handle auf einen Rückgabepuffer, in den\n            der Wert der API-Einstellung geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungZuruecksetzen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungLesen(
        name: *const ::std::os::raw::c_char,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die API-Einstellung @c name wird auf den @c wert gesetzt.\n\n Nach dem Laden der ERiC-Bibliotheken hat jede API-Einstellung\n ihren Standardwert. Mit dieser Funktion kann der Wert\n verändert werden. Der Wertebereich der jeweiligen API-Einstellung\n ist zu beachten.\n\n Bei Pfad-Einstellungen muss auf Windows der Wert in der für Datei-Funktionen\n benutzten ANSI-Codepage, auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale\n und auf macOS in der \"decomposed form\" von UTF-8 übergeben werden.\n Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n Pfaden und Pfadtrennzeichen beachten.\n Für Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n \"Übergabe von Pfaden an ERiC API-Funktionen\"\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n @param[in] wert Wert der API-Einstellung, NULL-terminierte Zeichenfolge.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_EINSTELLUNG_WERT_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungLesen()\n      - EricEinstellungZuruecksetzen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungSetzen(
        name: *const ::std::os::raw::c_char,
        wert: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der Wert der API-Einstellung @c name wird auf den Standardwert zurück gesetzt.\n\n Die Standardwerte sind im Dokument ERiC-Entwicklerhandbuch.pdf,\n Kap. \"Vorbelegung der ERiC-Einstellungen\" zu finden.\n\n @param[in] name Name der API-Einstellung, NULL-terminierte Zeichenfolge.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EINSTELLUNG_NAME_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - EricEinstellungSetzen()\n      - EricEinstellungLesen()\n      - EricEinstellungAlleZuruecksetzen()\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Bedeutung der ERiC-Einstellungen\""]
    pub fn EricEinstellungZuruecksetzen(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Alle verwendeten Plugin-Bibliotheken werden entladen und deren Speicher wird freigegeben.\n\n Der ERiC lädt die für die Bearbeitung notwendigen Plugin-Bibliotheken permanent\n in den Speicher und gibt diese erst mit dem Aufruf dieser Funktion wieder frei.\n \\n Falls eine Plugin-Bibliothek nicht entladen werden kann,\n wird dies in eric.log protokolliert. Der Returncode ist immer ::ERIC_OK.\n\n @note\n       Wenn die Steuersoftware darauf angewiesen ist, den ERiC erfolgreich\n       und komplett zu entladen, muss zuvor EricEntladePlugins() aufgerufen werden.\n\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n - ERiC-Entwicklerhandbuch.pdf, Kap. \"Verwendung von EricEntladePlugins()\""]
    pub fn EricEntladePlugins() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Konvertiert ein Einheitswert-Aktenzeichen im ELSTER-Format in ein landesspezifisches Bescheidformat\n\n Konvertiert ein Einheitswert-Aktenzeichen im ELSTER-Format (z.B. 2831400190001250002)\n in ein landesspezifisches Einheitswert-Aktenzeichen im Bescheidformat (z.B. 3100190001250002).\n\n @param[in] ewAzElster\n            Zeiger auf ein Einheitswert-Aktenzeichen im ELSTER-Format  (z.B. 2831400190001250002)\n\n @param[out] ewAzBescheidPuffer Handle auf einen Rückgabepuffer, in den\n            das Einheitswert-Aktenzeichen im Bescheidformat (z.B. 3100190001250002) geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n"]
    pub fn EricFormatEWAz(
        ewAzElster: *const byteChar,
        ewAzBescheidPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Steuernummer @c eingabeSteuernummer wird in das Bescheid-Format des jeweiligen Bundeslandes umgewandelt.\n\n @param[in] eingabeSteuernummer\n            Gültige, zu formatierende Steuernummer im\n            ELSTER-Steuernummernformat.\n @param[out] rueckgabePuffer Handle auf einen Rückgabepuffer, in den\n            die formatierte Steuernummer im Bescheid-Format des\n            jeweiligen Bundeslandes geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n     - ::ERIC_OK\n     - ::ERIC_GLOBAL_NULL_PARAMETER\n     - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n     - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n     - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n     - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n     - Pruefung_der_Steuer_und_Steueridentifikatsnummer.pdf"]
    pub fn EricFormatStNr(
        eingabeSteuernummer: *const byteChar,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Auswahlliste(n) für @c datenartVersion oder @c feldkennung wird zurück geliefert.\n\n Anwendungsfälle:\n 1. Parameter @c feldkennung ist nicht NULL: Die Funktion liefert die zur @c feldkennung und @c datenartVersion gehörige Auswahlliste.\n 2. Parameter @c feldkennung ist NULL: Die Funktion liefert alle zur @c datenartVersion gehörigen Feldkennungen mit hinterlegten Auswahllisten.\n\n Für die Ermittlung der Auswahllisten vieler Feldkennungen wird aus Performanzgründen Anwendungsfall 2 empfohlen.\n Die Funktion liefert Auswahllisten zu Feldkennungen vom Format \"NichtAbgeschlosseneEnumeration\" zurück.\n Diese Auswahllisten werden auch in der Jahres-/Deltadokumentation dokumentiert.\n\n @param[in] datenartVersion\n            Dieser Parameter darf nicht NULL sein.\n            Die gültigen Datenartversionen sind in Dokumentation\\Datenartversionmatrix.xml enthalten.\n @param[in] feldkennung\n            Feldkennung, für welche die Auswahlliste zu ermitteln ist.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            die angeforderten Auswahlliste(n) als XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition in Dokumentation\\API-Rueckgabe-Schemata\\EricGetAuswahlListen.xsd.\n            \\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricGetAuswahlListen xmlns=\"http://www.elster.de/EricXML/1.0/EricGetAuswahlListen\">\n     <AuswahlListe>\n         <Feldkennung>0104110</Feldkennung>\n         <ListenElement>Arbeitslosengeld</ListenElement>\n         <ListenElement>Elterngeld</ListenElement>\n         <ListenElement>Insolvenzgeld</ListenElement>\n         <ListenElement>Krankengeld</ListenElement>\n         <ListenElement>Mutterschaftsgeld</ListenElement>\n     </AuswahlListe>\n </EricGetAuswahlListen>\n \\endcode\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_KEINE_DATEN_VORHANDEN\n         - ::ERIC_GLOBAL_DATENARTVERSION_UNBEKANNT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricGetAuswahlListen(
        datenartVersion: *const ::std::os::raw::c_char,
        feldkennung: *const ::std::os::raw::c_char,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Aus dem Antwort-XML des Finanzamtservers wird das Transferticket und Returncodes/Fehlermeldungen zurückgegeben.\n\n Die Funktion liefert bei erfolgreicher Ausführung:\n - Das Transferticket aus dem Antwort-XML in dem Parameter @c transferticketPuffer.\n - Den Returncode und die Fehlermeldung aus dem Transferheader\n in den Parametern @c returncodeTHPuffer und @c fehlertextTHPuffer.\n - Für jeden Nutzdatenheader dessen Returncode und Fehlermeldung als XML-Daten im\n Parameter @c returncodesUndFehlertexteNDHXmlPuffer nach XML Schema Definition\n Dokumentation\\API-Rueckgabe-Schemata\\EricGetErrormessagesFromXMLAnswer.xsd.\n Enthält das Antwort-XML keine Nutzdaten, wird kein \\<Fehler\\> Element zurückgegeben.\n\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] xml\n            Antwort-XML des ELSTER-Servers, das ausgewertet\n            werden soll. Der originale XML-Server-Datenstrom\n            sollte unverändert übergeben werden und darf\n            insbesondere keine Zeilenumbruchzeichen enthalten.\n @param[out] transferticketPuffer Handle auf einen Rückgabepuffer, in den\n            das Transferticket geschrieben wird, siehe ::EricRueckgabepufferHandle.\n @param[out] returncodeTHPuffer Handle auf einen Rückgabepuffer, in den\n            der Returncode aus dem Transferheader geschrieben wird.\n            Siehe ::EricRueckgabepufferHandle.\n @param[out] fehlertextTHPuffer Handle auf einen Rückgabepuffer, in den\n            die Fehlermeldung aus dem Transferheader geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n @param[out] returncodesUndFehlertexteNDHXmlPuffer Handle auf einen\n            Rückgabepuffer, in den die Liste der Returncodes nach XML-Schema\n            Dokumentation\\API-Rueckgabe-Schemata\\EricGetErrormessagesFromXMLAnswer.xsd\n            geschrieben werden, siehe ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricGetErrormessagesFromXMLAnswer xmlns=\"http://www.elster.de/EricXML/1.0/EricGetErrormessagesFromXMLAnswer\">\n     <Fehler>\n       <Code>1</Code>\n       <Meldung>Fehlermeldung 1</Meldung>\n     </Fehler>\n     <Fehler>\n       <Code>2</Code>\n       <Meldung>Fehlermeldung 2</Meldung>\n     </Fehler>\n     (...)\n </EricGetErrormessagesFromXMLAnswer>\n \\endcode\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_IO_PARSE_FEHLER\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_PUFFER_ZUGRIFFSKONFLIKT\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n\n @note\n - Diese Funktion kann nicht dafür verwendet werden, die Antwort im Datenteil\n   aus einer dekodierten Serverantwort für Lohnsteuerbescheinigungen\n   auszuwerten.\n\n @see\n      - XML-Schema des Transferheaders: Dokumentation\\Schnittstellenbeschreibungen\\ElsterBasisSchema\\Schema\\th000011_extern.xsd\n      - XML-Schema des Nutzdatenheaders: Dokumentation\\Schnittstellenbeschreibungen\\ElsterBasisSchema\\Schema\\ndh000011.xsd\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Schnittstellenbeschreibungen\",\n        Tabelle \"Ergänzende Softwarepakete und Dateien – Schnittstellenbeschreibungen\""]
    pub fn EricGetErrormessagesFromXMLAnswer(
        xml: *const ::std::os::raw::c_char,
        transferticketPuffer: EricRueckgabepufferHandle,
        returncodeTHPuffer: EricRueckgabepufferHandle,
        fehlertextTHPuffer: EricRueckgabepufferHandle,
        returncodesUndFehlertexteNDHXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Für das übergebene Zertifikat in @c pathToKeystore wird das Handle @c hToken\n        und die unterstützten PIN-Werte @c iInfoPinSupport zurückgeliefert.\n\n Die ERiC API benötigt Zertifikat-Handles typischerweise\n bei kryptografischen Operationen.\n \\n Zertifikat-Handles sollten möglichst frühzeitig, d.h. wenn sie nicht\n mehr benötigt werden, mit EricCloseHandleToCertificate() freigegeben\n werden, spätestens jedoch zum Programmende bzw. vor dem Entladen der\n ericapi Bibliothek.\n\n @param[out] hToken Handle zu einem der folgenden Zertifikate:\n                      - Portalzertifikat\n                      - clientseitig erzeugtes Zertifikat\n                      - Ad Hoc-Zertifikat für den neuen Personalausweis\n @param[out] iInfoPinSupport\n            Wird in @c iInfoPinSupport ein Zeiger ungleich NULL übergeben und die Funktion mit ::ERIC_OK beendet,\n            dann enthält @c iInfoPinSupport einen vorzeichenlosen Integer-Wert.\n            In diesem Wert ist kodiert abgelegt, ob eine PIN-Eingabe\n            erforderlich ist und welche PIN-Statusinformationen\n            unterstützt werden.\n            Die kodierten Werte (nachfolgend in hexadezimaler Form angegeben)\n            können durch ein binäres ODER kombiniert werden und bedeuten im\n            Einzelnen:\n            - 0x00: Keine PIN-Angabe erforderlich, kein PIN-Status unterstützt.\n            - 0x01: PIN-Angabe für Signatur erforderlich.\n            - 0x02: PIN-Angabe für Entschlüsselung erforderlich.\n            - 0x04: PIN-Angabe für Verschlüsselung des Zertifikats erforderlich.\n            - 0x08: reserviert (wird derzeit nicht verwendet)\n            - 0x10: PIN-Status \"Pin Ok\" wird unterstützt.\n            - 0x20: PIN-Status \"Der letzte Versuch der Pin-Eingabe schlug fehl\" wird unterstützt.\n            - 0x40: PIN-Status \"Beim nächsten fehlerhaften Versuch wird die Pin gesperrt\" wird unterstützt.\n            - 0x80: PIN-Status \"Pin ist gesperrt\" wird unterstützt.\n            \\n Falls vom Aufrufer NULL übergeben wird, gibt die Funktion nichts zurück.\n @param[in] pathToKeystore\n            1. Clientseitig erzeugtes Zertifikat: <br>\n              Pfad zum Verzeichnis, in dem sich die Zertifikats-Datei (.cer)\n              und die Datei mit dem privaten Schlüssel (.p12) befinden.\n              Diese Kryptomittel wurden mit EricCreateKey() erzeugt.\n              Der Pfad zum Verzeichnis ist bei clientseitig erzeugten\n              Zertifikaten relativ zum aktuellen Arbeitsverzeichnis oder absolut\n              anzugeben.\n            2. Software-Portalzertifikat: <br>\n              Pfad zur Software-Zertifikatsdatei (i.d.R. mit der Endung .pfx).\n              Der Pfad zur Datei ist bei Software-Zertifikaten relativ zum\n              aktuellen Arbeitsverzeichnis oder absolut anzugeben.\n            3. Sicherheitsstick: <br>\n              Pfad zur Treiberdatei, siehe (1). Bitte beachten, dass der Treiber\n              betriebssystemabhängig sein kann. Weitere Informationen in der\n              Anleitung zum Sicherheitsstick oder unter\n              https://www.sicherheitsstick.de .\n            4. Signaturkarte: <br>\n              Pfad zur Treiberdatei, welcher einen Zugriff auf die\n              Signaturkarte ermöglicht, siehe (1). Weitere Informationen in\n              der Anleitung zur Signaturkarte.\n            5. Neuer Personalausweis (nPA): <br>\n              URL des eID-Clients wie zum Beispiel der AusweisApp 2\n              In den meisten Fällen lautet diese URL: http://127.0.0.1:24727/eID-Client\n              Optional kann auf die folgende Weise noch ein Testmerker angehängt werden:\n              http://127.0.0.1:24727/eID-Client?testmerker=520000000\n              Zu den verfügbaren Testmerkern siehe ERiC-Entwicklerhandbuch.pdf,\n              Kap. \"Test Unterstützung bei der ERiC-Anbindung\".\n              \\n\\b Wichtig: Das Ad Hoc-Zertifikat, das in diesem Fall für den neuen\n                       Personalausweis erzeugt wird, ist nur 24 Stunden gültig.\n\n            (1) Bei Sicherheitssticks und Signaturkarten ist bei der Angabe\n            des Treibers der Suchmechanismus nach dynamischen Modulen des\n            jeweiligen Betriebssystems zu berücksichtigen. Weitere\n            Informationen sind z.B. unter Windows der Dokumentation der\n            LoadLibrary() oder unter Linux und macOS der Dokumentation der\n            dlopen() zu entnehmen.\n\n            Pfade müssen auf Windows in der für Datei-Funktionen benutzten ANSI-Codepage,\n            auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale\n            und auf macOS in der \"decomposed form\" von UTF-8 übergeben werden.\n            Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n            Pfaden und Pfadtrennzeichen beachten.\n            Für Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n            \"Übergabe von Pfaden an ERiC API-Funktionen\"\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_GLOBAL_UNKNOWN\n         - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n         - ::ERIC_CRYPT_E_MAX_SESSION\n         - ::ERIC_CRYPT_E_PSE_PATH\n         - ::ERIC_CRYPT_E_BUSY\n         - ::ERIC_CRYPT_E_P11_SLOT_EMPTY\n         - ::ERIC_CRYPT_E_NO_SIG_ENC_KEY\n         - ::ERIC_CRYPT_E_LOAD_DLL\n         - ::ERIC_CRYPT_E_NO_SERVICE\n         - ::ERIC_CRYPT_E_ESICL_EXCEPTION\n \\n\\n <b>Nur bei Verwendung des neuen Personalausweises:</b>\n         - ::ERIC_TRANSFER_EID_CLIENTFEHLER\n         - ::ERIC_TRANSFER_EID_FEHLENDEFELDER\n         - ::ERIC_TRANSFER_EID_IDENTIFIKATIONABGEBROCHEN\n         - ::ERIC_TRANSFER_EID_NPABLOCKIERT\n         - ::ERIC_TRANSFER_EID_IDNRNICHTEINDEUTIG\n         - ::ERIC_TRANSFER_EID_KEINCLIENT\n         - ::ERIC_TRANSFER_EID_KEINKONTO\n         - ::ERIC_TRANSFER_EID_SERVERFEHLER\n         - ::ERIC_TRANSFER_ERR_CONNECTSERVER\n         - ::ERIC_TRANSFER_ERR_NORESPONSE\n         - ::ERIC_TRANSFER_ERR_PROXYAUTH\n         - ::ERIC_TRANSFER_ERR_PROXYCONNECT\n         - ::ERIC_TRANSFER_ERR_SEND\n         - ::ERIC_TRANSFER_ERR_SEND_INIT\n         - ::ERIC_TRANSFER_ERR_TIMEOUT\n\n @see\n         - EricCloseHandleToCertificate()\n         - EricGetPinStatus()"]
    pub fn EricGetHandleToCertificate(
        hToken: *mut EricZertifikatHandle,
        iInfoPinSupport: *mut u32,
        pathToKeystore: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der PIN-Status wird für ein passwortgeschütztes Kryptomittel abgefragt und in @c pinStatus zurückgegeben.\n\n Der PIN-Status wird für einen passwortgeschützten Bereich\n ermittelt, der durch das übergebene Zertifikat-Handle im\n Parameter @c hToken referenziert wird. Da bei Sicherheitssticks\n und Signaturkarten durch ein einziges Zertifikat-Handle zwei\n Schlüsselpaare referenziert werden können (eines für die\n Signatur und eines für die Verschlüsselung von Daten),\n muss grundsätzlich der Parameter @c keyType gesetzt werden.\n \\n Mit dem Rückgabewert der Funktion kann der Endanwender\n rechtzeitig informiert werden, falls bei einer weiteren\n falschen PIN-Eingabe das Kryptomittel gesperrt wird. Im\n Fehlerfall ist @c pinStatus nicht definiert.\n \\n Der Karten- bzw. Stickhersteller ist verantwortlich,\n dass seine Implementierung den korrekten PIN-Status\n zurückgibt, siehe auch\n Tabelle \"PIN-Statusabfrage für POZ\" im Unterkap.\n \"Das Portalzertifikat (POZ)\" im Dokument\n ERiC-Entwicklerhandbuch.pdf.\n\n @param[in] hToken\n            Zertifikat-Handle für dessen passwortgeschützten\n            Bereich der PIN-Status ermittelt werden soll.\n            Wird von der Funktion\n            EricGetHandleToCertificate() zurückgeliefert.\n @param[out] pinStatus\n            Mögliche Rückgabewerte:\n            - 0: StatusPinOk: Kein Fehlversuch oder keine\n                 Informationen verfügbar\n            - 1: StatusPinLocked: PIN gesperrt\n            - 2: StatusPreviousPinError: Die letzte\n                 PIN-Eingabe war fehlerhaft\n            - 3: StatusLockedIfPinError: Beim nächsten\n                 fehlerhaften Versuch wird die PIN gesperrt\n @param[in] keyType\n            Mögliche Eingabewerte:\n            - 0: eSignatureKey: Schlüssel für die Signatur\n                 von Daten\n            - 1: eEncryptionKey: Schlüssel für die\n                 Verschlüsselung von Daten\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - weitere, siehe eric_fehlercodes.h\n\n @see\n     - EricGetHandleToCertificate()\n     - ERiC-Entwicklerhandbuch.pdf, Kap. \"Zertifikate und Authentifizierungsverfahren\"\n"]
    pub fn EricGetPinStatus(
        hToken: EricZertifikatHandle,
        pinStatus: *mut u32,
        keyType: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird der öffentliche Schlüssel als base64-kodierte Zeichenkette\n        für das übergebene Zertifikat in @c cryptoParameter zurückgeliefert.\n\n @param[in] cryptoParameter\n            Die Struktur enthält das Zertifikat-Handle und die PIN. Der Abrufcode wird ignoriert.\n            Falls der Zugriff auf den öffentlichen Schlüssel keine PIN erfordert,\n            ist PIN=NULL anzugeben.\n @param[out] rueckgabePuffer\n            Handle auf den Rückgabepuffer. Bei Erfolg enthält\n            der Rückgabepuffer den öffentlichen Schlüssel als base64-kodierte Zeichenkette.\n            \\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n         - ::ERIC_OK\n         - ::ERIC_GLOBAL_NULL_PARAMETER\n         - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n         - ::ERIC_CRYPT_E_INVALID_HANDLE\n         - ::ERIC_CRYPT_E_P12_ENC_KEY\n         - ::ERIC_CRYPT_E_PIN_WRONG\n         - ::ERIC_CRYPT_E_PIN_LOCKED\n         - weitere, siehe eric_fehlercodes.h\n"]
    pub fn EricGetPublicKey(
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Es wird die Klartextfehlermeldung zu dem @c fehlerkode ermittelt.\n\n Die Funktion liefert die Klartextfehlermeldung zu einem\n ERiC Fehlercode - definiert in eric_fehlercodes.h\n\n\n @param[in] fehlerkode\n            Eingabe-Fehlercode, definiert in eric_fehlercodes.h.\n @param[out] rueckgabePuffer Handle auf einen Rückgabepuffer, in den\n            die Klartextfehlermeldung geschrieben wird.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle. \\n\n            Die Klartextfehlermeldung ist gemäß UTF-8 kodiert. \\n\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_FEHLERMELDUNG_NICHT_VORHANDEN\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFehlerText(
        fehlerkode: ::std::os::raw::c_int,
        rueckgabePuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird die Finanzamtliste für eine bestimmte @c finanzamtLandNummer zurückgegeben.\n\n @param[in] finanzamtLandNummer\n              Die Finanzamtlandnummer besteht aus den ersten zwei Stellen der\n              Bundesfinanzamtsnummer. Eine Liste aller Finanzamtlandnummern wird\n              von ::EricHoleFinanzamtLandNummern() zurückgegeben.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzaemter.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleFinanzaemter xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleFinanzaemter\">\n     <Finanzamt>\n       <BuFaNummer>2801</BuFaNummer>\n       <Name>Finanzamt Offenburg Außenstelle Achern</Name>\n     </Finanzamt>\n     <Finanzamt>\n       <BuFaNummer>2804</BuFaNummer>\n       <Name>Finanzamt Villingen-Schwenningen Außenstelle Donaueschingen</Name>\n     </Finanzamt>\n     (...)\n </EricHoleFinanzaemter>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_UTI_COUNTRY_NOT_SUPPORTED\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFinanzaemter(
        finanzamtLandNummer: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Liste aller Finanzamtlandnummern wird zurückgegeben.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzamtLandNummern.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleFinanzamtLandNummern xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleFinanzamtLandNummern\">\n     <FinanzamtLand>\n       <FinanzamtLandNummer>28</FinanzamtLandNummer>\n       <Name>Baden-Württemberg</Name>\n     </FinanzamtLand>\n     <FinanzamtLand>\n       <FinanzamtLandNummer>91</FinanzamtLandNummer>\n       <Name>Bayern (Zuständigkeit LfSt - München)</Name>\n     </FinanzamtLand>\n     (...)\n </EricHoleFinanzamtLandNummern>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleFinanzamtLandNummern(
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c finanzamtsdaten werden für eine Bundesfinanzamtsnummer zurückgegeben.\n\n Die Bundesfinanzamtsnummer kann über die Kombination der Funktionen ::EricHoleFinanzamtLandNummern()\n und ::EricHoleFinanzaemter() ermittelt werden.\n\n @param[in] bufaNr\n            Übergabe der 4-stelligen Bundesfinanzamtsnummer.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleFinanzamtsdaten.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c bufaNr ist NULL.\n        - ::ERIC_GLOBAL_PRUEF_FEHLER: Die übergebene Bundesfinanzamtsnummer ist keine Ganzzahl.\n        - ::ERIC_GLOBAL_KEINE_DATEN_VORHANDEN: Immer bei Testfinanzämtern.\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n    - ::EricHoleFinanzamtLandNummern()\n    - ::EricHoleFinanzaemter()"]
    pub fn EricHoleFinanzamtsdaten(
        bufaNr: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Testfinanzamtliste wird in @c rueckgabeXmlPuffer zurückgegeben.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            die Ergebnis XML-Daten geschrieben werden.\n            Die XML-Daten folgen der XML Schema Definition\n            Dokumentation\\API-Rueckgabe-Schemata\\EricHoleTestFinanzaemter.xsd.\n            Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricHoleTestFinanzaemter xmlns=\"http://www.elster.de/EricXML/1.0/EricHoleTestFinanzaemter\">\n   <Finanzamt>\n       <BuFaNummer>1096</BuFaNummer>\n       <Name>Testfinanzamt Saarland</Name>\n     </Finanzamt>\n     <Finanzamt>\n       <BuFaNummer>1097</BuFaNummer>\n       <Name>Finanzschule (Edenkoben)</Name>\n     </Finanzamt>\n     (...)\n </EricHoleTestFinanzaemter>\n \\endcode\n\n @return\n        - ::ERIC_OK\n        - ::ERIC_GLOBAL_NULL_PARAMETER\n        - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n        - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n        - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricHoleTestfinanzaemter(
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die Eigenschaften des übergebenen Zertifikats werden im @c rueckgabeXmlPuffer zurückgegeben.\n\n @param[in] hToken Handle des Zertifikats, dessen Eigenschaften geholt werden sollen.\n            Wird von der Funktion EricGetHandleToCertificate() zurückgeliefert.\n @param[in] pin PIN zum Öffnen des Zertifikats. Wird bei Software-Portalzertifikaten\n            benötigt.\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den die Zertifikateigenschaften\n             im XML-Format geschrieben werden. Das Format ist im XML Schema\n             Dokumentation\\API-Rueckgabe-Schemata\\EricHoleZertifikatEigenschaften.xsd\n             definiert.\n             Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n @note       Bei einem ELSTER-Softwarezertifikat (.pfx) steht im Common Name (CN) die ID des ELSTER-Kontos,\n             für das das Zertifikat ausgestellt wurde.\n             Die Konto-ID kann beispielsweise dafür genutzt werden, bei einer Zertifikatsverlängerung\n             das verlängerte Zertifikat dem alten Zertifikat zuzuordnen.\n\n \\b Beispiel:\n \\code\n <EricHoleZertifikatEigenschaften xmlns=\"http://www.elster.de/EricXML/2.0/EricHoleZertifikatEigenschaften\">\n   <Signaturzertifikateigenschaften>\n       <AusgestelltAm>220817152116Z</AusgestelltAm>\n       <GueltigBis>230817152116Z</GueltigBis>\n       <Signaturalgorithmus>sha1WithRSAEncryption(1.2.840.113549.1.1.5)</Signaturalgorithmus>\n       <PublicKeyMD5>6b8b191936677957fe74103198e77f4e</PublicKeyMD5>\n       <PublicKeySHA1>884b0dfe2e10221a2aedd28c986cf34db0f1d932</PublicKeySHA1>\n       <PublicKeyBitLength>2048</PublicKeyBitLength>\n       <Issuer>\n           <Info><Name>CN</Name><Wert>ElsterSoftCA</Wert></Info>\n           <Info><Name>OU</Name><Wert>CA</Wert></Info>\n           (...)\n       </Issuer>\n       <Subjekt>\n           <Info><Name>CN</Name><Wert>1000872896</Wert></Info>\n       </Subjekt>\n       <Identifikationsmerkmaltyp>Steuernummer</Identifikationsmerkmaltyp>\n       <Registrierertyp>Person</Registrierertyp>\n       <Verifikationsart>Postweg</Verifikationsart>\n       <TokenTyp>Software</TokenTyp>\n       <Testzertifikat>true</Testzertifikat>\n   </Signaturzertifikateigenschaften>\n   <Verschluesselungszertifikateigenschaften>\n       (...)\n   </Verschluesselungszertifikateigenschaften>\n </EricHoleZertifikatEigenschaften>\n \\endcode\n\n @return\n      - ::ERIC_OK\n      - ::ERIC_GLOBAL_NULL_PARAMETER\n      - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n      - ::ERIC_GLOBAL_UNKNOWN\n      - ERIC_CRYPT_E_*: Ein Zertifikatsfehler aus dem Statuscodebereich\n                        von ::ERIC_CRYPT_E_INVALID_HANDLE = 610201101 bis 610201212\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"Verwendung von EricHoleZertifikatEigenschaften()\"\n      - Dokumentation\\API-Rueckgabe-Schemata\\EricHoleZertifikatEigenschaften.xsd\n"]
    pub fn EricHoleZertifikatEigenschaften(
        hToken: EricZertifikatHandle,
        pin: *const byteChar,
        rueckgabeXmlPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Der Fingerabdruck und dessen Signatur wird für das übergebene\n         Zertifikat zurückgegeben.\n\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] cryptoParameter Zertifikatsdaten,\n            siehe eric_verschluesselungs_parameter_t.\n            Das in der übergebenen Struktur referenzierte Zertifikat muss\n            ein clientseitig erzeugtes Zertifikat (CEZ) sein.\n @param[out] fingerabdruckPuffer Handle auf einen Rückgabepuffer, in\n            den der Fingerabdruck geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n @param[out] signaturPuffer Handle auf einen Rückgabepuffer, in den\n            die Signatur des Fingerabdrucks geschrieben wird, siehe\n            ::EricRueckgabepufferHandle.\n\n @note Die Erzeugung eines Fingerabdrucks mit dieser Funktion ist nur\n       in Zusammenhang mit clientseitig erzeugten Zertifikaten definiert.\n\n @return\n - ::ERIC_OK\n - ::ERIC_GLOBAL_NULL_PARAMETER\n - ::ERIC_GLOBAL_PUFFER_ZUGRIFFSKONFLIKT\n - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n - ::ERIC_GLOBAL_UNKNOWN\n - ::ERIC_CRYPT_E_P12_READ\n - ::ERIC_CRYPT_E_P12_DECODE\n - ::ERIC_CRYPT_E_PIN_WRONG\n - ::ERIC_CRYPT_E_P12_SIG_KEY\n - ::ERIC_CRYPT_E_P12_ENC_KEY\n - ::ERIC_CRYPT_ZERTIFIKAT\n - ::ERIC_CRYPT_EIDKARTE_NICHT_UNTERSTUETZT\n - ::ERIC_CRYPT_SIGNATUR\n - ::ERIC_CRYPT_CORRUPTED"]
    pub fn EricHoleZertifikatFingerabdruck(
        cryptoParameter: *const eric_verschluesselungs_parameter_t,
        fingerabdruckPuffer: EricRueckgabepufferHandle,
        signaturPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialisiert den Singlethreading-ERiC\n\n Vor der Verwendung der Singlethreading-API muss ::EricInitialisiere()\n aufgerufen werden.\n\n Mehrfache Aufrufe dieser Funktion, ohne das zwischendurch\n ::EricBeende() aufgerufen worden ist, führen dazu, dass der\n Fehlercode ::ERIC_GLOBAL_MEHRFACHE_INITIALISIERUNG zurückgegeben\n wird. Der zuvor initialisierte Singlethreading-ERiC bleibt davon\n aber unberührt und ist weiterhin in einem gültigen Zustand.\n\n @param[in] pluginPfad Pfad, in dem die Plugins rekursiv gesucht werden.\n                       Ist der Zeiger gleich \\c NULL, wird der Pfad zur\n                       Bibliothek ericapi verwendet.\n @param[in] logPfad Optionaler Pfad zur Log-Datei eric.log. Ist der\n                    Wert gleich \\c NULL, wird das betriebssystemspezifische\n                    Verzeichnis für temporäre Dateien verwendet.\n\n @note Kann kein eric.log angelegt werden, wird eine entsprechende\n       Fehlermeldung auf die Konsole (stderr) geschrieben und an den\n       Windows-Ereignisdienst bzw. den syslogd-Dienst (Linux, AIX, macOS)\n       geschickt.\n       Für Linux, AIX und macOS ist zu beachten, dass der syslogd-Dienst\n       gegebenenfalls erst noch zu aktivieren und für die Protokollierung\n       von Meldungen der Facility \"User\" zu konfigurieren ist.\n       Suchkriterien für ERiC-Meldungen in der Windows-Ereignisansicht\n       sind \"ERiC (Elster Rich Client)\" als Quelle und \"Anwendung\"\n       als Protokoll.\n       Suchkriterien für ERiC-Meldungen in den Systemlogdateien\n       unter Linux, AIX und macOS sind die Facility \"User\" und\n       der Ident \"ERiC (Elster Rich Client)\".\n\n @return\n             - ::ERIC_OK\n             - ::ERIC_GLOBAL_MEHRFACHE_INITIALISIERUNG\n             - ::ERIC_GLOBAL_FEHLER_INITIALISIERUNG\n             - ::ERIC_GLOBAL_LOG_EXCEPTION\n\n @see\n      - ::EricBeende()"]
    pub fn EricInitialisiere(
        pluginPfad: *const byteChar,
        logPfad: *const byteChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird eine Steuernummer im ELSTER-Steuernummerformat erzeugt.\n\n Die Funktion erzeugt aus einer angegebenen Steuernummer\n im Format des Steuerbescheides eine 13-stellige\n Steuernummer im ELSTER-Steuernummerformat.<br>\n\n Die sich ergebende 13-stellige Steuernummer im\n ELSTER-Steuernummerformat wird von der Funktion\n ::EricMakeElsterStnr() auch auf Gültigkeit geprüft.<br>\n\n Einer der beiden Parameter @c landesnr oder @c bundesfinanzamtsnr muss\n korrekt angegeben werden. Der jeweils andere Parameter darf NULL oder leer\n sein. Bei bayerischen und berliner Steuernummern im Format BBB/UUUUP ist die\n Angabe der Bundesfinanzamtsnummer zwingend erforderlich.\n\n @param[in]  steuernrBescheid\n             Format der Steuernummer wie auch auf amtlichen\n             Schreiben angegeben.\n @param[in]  landesnr\n             2-stellige Landesnummer (entspricht den ersten\n             zwei Stellen der Bundesfinanzamtsnummer).\n @param[in]  bundesfinanzamtsnr\n             4-stellige Bundesfinanzamtsnummer.\n @param[out] steuernrPuffer Handle auf einen Rückgabepuffer, in den\n             die Steuernummer im ELSTER-Steuernummerformat geschrieben wird.\n             Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n             siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_LANDESNUMMER_UNBEKANNT\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricMakeElsterStnr(
        steuernrBescheid: *const byteChar,
        landesnr: *const byteChar,
        bundesfinanzamtsnr: *const byteChar,
        steuernrPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Konvertiert ein Einheitswert-Aktenzeichen in das ELSTER-Format\n\n Konvertiert ein gültiges Einheitswert-Aktenzeichen in einem landesspezifischen Bescheidformat (z.B. 208/035-3-03889.3)\n unter Angabe des Landeskürzels in ein Einheitswert-Aktenzeichen im ELSTER-Format (z.B. 520840353038893).\n\n @param[in] ewAzBescheid\n            Zeiger auf das Einheitswert-Aktenzeichen in einem landesspezifischen Bescheidformat.\n @param[in] landeskuerzel\n            Zeiger auf das Landeskürzel (zum Beispiel BY für Bayern)\n @param[out] ewAzElsterPuffer Handle auf einen Rückgabepuffer, in den\n             das erzeugte Einheitswert-Aktenzeichen im ELSTER-Format geschrieben wird.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n  - ::ERIC_GLOBAL_EWAZ_LANDESKUERZEL_UNBEKANNT\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n     - Landeskürzel siehe ISO-3166-2"]
    pub fn EricMakeElsterEWAz(
        ewAzBescheid: *const byteChar,
        landeskuerzel: *const byteChar,
        ewAzElsterPuffer: EricRueckgabepufferHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c bic wird auf Gültigkeit überprüft.\n\n Die Prüfung erfolgt in zwei Schritten:\n\n -# Formale Prüfung auf gültige Zeichen und richtige Länge.\n -# Prüfung, ob das Länderkennzeichen für BIC gültig ist.\n\n Falls die BIC ungültig ist liefert die Funktion EricHoleFehlerText()\n den zugehörigen Fehlertext.\n\n @param[in] bic Zeiger auf eine NULL-terminierte Zeichenkette.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_BIC_FORMALER_FEHLER: Ungültige Zeichen, falsche Länge.\n  - ::ERIC_GLOBAL_BIC_LAENDERCODE_FEHLER\n  - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c bic ist NULL.\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"BIC ISO-Ländercodes\"\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"BIC-Prüfung\""]
    pub fn EricPruefeBIC(bic: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c iban wird auf Gültigkeit überprüft.\n\n Die Prüfung erfolgt in vier Schritten:\n\n -# Formale Prüfung auf gültige Zeichen und richtige Länge.\n -# Prüfung, ob das Länderkennzeichen für IBAN gültig ist.\n -# Prüfung, ob das länderspezifische Format gültig ist.\n -# Prüfung, ob die Prüfziffer der IBAN gültig ist.\n\n Falls die IBAN ungültig ist liefert die Funktion EricHoleFehlerText()\n den zugehörigen Fehlertext.\n\n @param[in] iban Zeiger auf eine NULL-terminierte Zeichenkette.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_IBAN_FORMALER_FEHLER: Ungültige Zeichen, falsche Länge.\n  - ::ERIC_GLOBAL_IBAN_LAENDERCODE_FEHLER\n  - ::ERIC_GLOBAL_IBAN_LANDESFORMAT_FEHLER\n  - ::ERIC_GLOBAL_IBAN_PRUEFZIFFER_FEHLER\n  - ::ERIC_GLOBAL_NULL_PARAMETER: Parameter @c iban ist NULL.\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"IBAN - länderspezifische Formate\"\n      - ERiC-Entwicklerhandbuch.pdf, Kap. \"IBAN-Prüfung\"\n"]
    pub fn EricPruefeIBAN(iban: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Überprüft ein @c Einheitswert-Aktenzeichen im ELSTER-Format auf Gültigkeit.\n\n @param[in] einheitswertAz\n            Zeiger auf ein Einheitswert-Aktenzeichen im ELSTER-Format\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_EWAZ_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n"]
    pub fn EricPruefeEWAz(einheitswertAz: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c steuerId wird auf Gültigkeit überprüft.\n\n @param[in] steuerId\n            Steuer-Identifikationsnummer (IdNr)\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_IDNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricPruefeSteuernummer()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Prüfung der Steueridentifikationsnummer (IdNr)\"\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Test-Steueridentifikationsnummer\""]
    pub fn EricPruefeIdentifikationsMerkmal(steuerId: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c steuernummer wird einschließlich Bundesfinanzamtsnummer\n        auf formale Richtigkeit geprüft.\n\n Zur Prüfung der Bundesfinanzamtsnummer wird\n ::EricPruefeBuFaNummer() verwendet.\n\n Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern siehe Dokumentation\n zu ::EricRueckgabepufferHandle.\n\n @param[in] steuernummer NULL-terminierte 13-stellige Steuernummer im\n            ELSTER-Steuernummernformat.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_STEUERNUMMER_UNGUELTIG\n  - ::ERIC_GLOBAL_COMMONDATA_NICHT_VERFUEGBAR\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricPruefeBuFaNummer()\n         - Pruefung_der_Steuer-_und_Steueridentifikatsnummer.pdf"]
    pub fn EricPruefeSteuernummer(steuernummer: *const byteChar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Prüft, ob die @c pin zum Zertifikat @c pathToKeystore passt.\n        Nicht anwendbar auf Ad Hoc-Zertifikate (AHZ), die für einen\n        neuen Personalausweis (nPA) ausgestellt sind.\n\n @param[in] pathToKeystore\n            Folgende Zertifikatstypen werden unterstützt:\n            1. Clientseitig erzeugtes Zertifikat: <br>\n              Pfad zum Verzeichnis, in dem sich die Zertifikats-Datei (.cer)\n              und die Datei mit dem privaten Schlüssel (.p12) befinden.\n              Diese Kryptomittel wurden mit EricCreateKey() erzeugt.\n              Der Pfad zum Verzeichnis ist bei clientseitig erzeugten\n              Zertifikaten relativ zum aktuellen Arbeitsverzeichnis oder absolut\n              anzugeben.\n            2. Software-Portalzertifikat: <br>\n              Pfad zur Software-Zertifikatsdatei (i.d.R. mit der Endung .pfx).\n              Der Pfad zur Datei ist bei Software-Zertifikaten relativ zum\n              aktuellen Arbeitsverzeichnis oder absolut anzugeben.\n            3. Sicherheitsstick: <br>\n              Pfad zur Treiberdatei, siehe (2). Bitte beachten, dass der Treiber\n              betriebssystemabhängig sein kann. Weitere Informationen in der\n              Anleitung zum Sicherheitsstick oder unter\n              https://www.sicherheitsstick.de .\n            4. Signaturkarte: <br>\n              Pfad zur Treiberdatei, welcher einen Zugriff auf die\n              Signaturkarte ermöglicht, siehe (2). Weitere Informationen in\n              der Anleitung zur Signaturkarte.\n @param[in] pin\n            PIN für den Zugriff auf den privaten Schlüssel des Zertifikats.\n @param[in] keyType\n            Mögliche Eingabewerte:\n            - 0: eSignatureKey: Schlüssel für die Signatur von Daten, siehe (1).\n            - 1: eEncryptionKey: Schlüssel für die Verschlüsselung von Daten, siehe (1).\n\n  (1) Bei einem Zertifikat wie dem mit EricCreateKey() clientseitig\n  erzeugten Zertifikat (CEZ), das nur einen einzigen, gemeinsamen Schlüssel\n  für Signatur und Verschlüsselung besitzt, sind beide Eingabewerte\n  erlaubt. Die Werte beziehen sich dann beide auf denselben Schlüssel.\n\n  (2) Bei Sicherheitssticks und Signaturkarten ist bei der Angabe\n  des Treibers der Suchmechanismus nach dynamischen Modulen des\n  jeweiligen Betriebssystems zu berücksichtigen. Weitere\n  Informationen sind z.B. unter Windows der Dokumentation der\n  LoadLibrary() oder unter Linux und macOS der Dokumentation der\n  dlopen() zu entnehmen.\n\n  Pfade müssen auf Windows in der für Datei-Funktionen benutzten ANSI-Codepage,\n  auf Linux, AIX und Linux Power in der für das Dateisystem benutzten Locale\n  und auf macOS in der \"decomposed form\" von UTF-8 übergeben werden.\n  Bitte weitere Betriebssystemspezifika bzgl. nicht erlaubter Zeichen in\n  Pfaden und Pfadtrennzeichen beachten.\n  Für Details zu Pfaden im ERiC siehe Entwicklerhandbuch Kapitel\n  \"Übergabe von Pfaden an ERiC API-Funktionen\".\n\n  Es wird empfohlen, geöffnete Zertifikatshandle zu schließen, bevor mit\n  der API-Funktion EricPruefeZertifikatPin() das gewünschte Zertifikat geprüft wird.\n\n  @note Eine falsche PIN-Eingabe erhöht bei Sicherheitsstick und Signaturkarte den\n        Zähler für Fehlversuche. Welche Zertifikatstypen aufgrund von 3 Fehlversuchen\n        gesperrt werden, ist im ERiC-Entwicklerhandbuch.pdf Kap.\n        \"Das Portalzertifikat (POZ)\" beschrieben.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_CRYPT_E_PIN_WRONG\n  - ::ERIC_CRYPT_NICHT_UNTERSTUETZTES_PSE_FORMAT\n  - ::ERIC_CRYPT_EIDKARTE_NICHT_UNTERSTUETZT\n  - ::ERIC_CRYPT_E_PSE_PATH\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN"]
    pub fn EricPruefeZertifikatPin(
        pathToKeystore: *const byteChar,
        pin: *const byteChar,
        keyType: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die @c funktion wird als Callback-Funktion für\n        ::EricBearbeiteVorgang() registriert.\n\n Die registrierte Callback-Funktion wird von der Funktion\n ::EricBearbeiteVorgang() aufgerufen, um bei der Verarbeitung\n den Fortschritt der einzelnen Arbeitsbereiche anzuzeigen.\n\n @param funktion      Zeiger auf die zu registrierende Funktion oder \\c NULL.\n @param benutzerdaten Zeiger, der der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      übergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereFortschrittCallback() mit dem\n           Wert \\c NULL im Parameter \\c funktion aufzurufen.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgeführt werden.\n\n @see\n         - EricFortschrittCallback\n         - EricBearbeiteVorgang()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Funktionen für Fortschrittcallbacks\"\n"]
    pub fn EricRegistriereFortschrittCallback(
        funktion: EricFortschrittCallback,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die registrierte @c funktion wird als Callback-Funktion\n        von ::EricBearbeiteVorgang() aufgerufen und zeigt den\n        Gesamtfortschritt der Verarbeitung an.\n\n @param funktion      Zeiger auf die zu registrierende Funktion oder \\c NULL.\n @param benutzerdaten Zeiger, der der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      übergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereGlobalenFortschrittCallback()\n           mit dem Wert \\c NULL im Parameter \\c funktion aufzurufen.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer\n           Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgeführt werden.\n\n @see\n         - EricBearbeiteVorgang()\n         - ERiC-Entwicklerhandbuch.pdf, Kap. \"Funktionen für Fortschrittcallbacks\""]
    pub fn EricRegistriereGlobalenFortschrittCallback(
        funktion: EricFortschrittCallback,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Die registrierte @c funktion wird als Callback-Funktion für\n        jede Lognachricht aufgerufen.\n        Die Ausgabe entspricht einer Zeile im eric.log.\n\n @param funktion Zeiger auf die zu registrierende Funktion oder NULL.\n @param schreibeEricLogDatei\n          - \\c 1  Jede Log-Nachricht wird nach eric.log geschrieben.\n                  Der Parameter \\c funktion kann auf eine\n                  Funktion zeigen oder \\c NULL sein.\n          - \\c 0  Falls \\c funktion \\c != \\c NULL werden keine Log-Nachrichten\n                  nach eric.log geschrieben, andernfalls werden die\n                  Log-Nachrichten nach eric.log geschrieben.\n @param benutzerdaten Zeiger, welcher der registrierten Funktion immer\n                      mitgegeben wird. Die Anwendung kann diesen Parameter\n                      dazu verwenden, einen Zeiger auf eigene Daten oder\n                      Funktionen an die zu registrierende Funktion\n                      übergeben zu lassen.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @remark\n         - Wenn eine zuvor registrierte Funktion nicht mehr aufgerufen\n           werden soll, ist ::EricRegistriereLogCallback() mit dem Wert\n           \\c NULL im Parameter \\c funktion aufzurufen (=Deregistrierung).\n         - Vor dem Beenden der Steueranwendung ist eine registrierte\n           Funktion zu deregistrieren, da es sonst zu einem Absturz\n           kommen kann.\n         - Es ist nicht erlaubt eine ERiC API-Funktion aus einer\n           Callback-Funktion aufzurufen.\n         - Die Verarbeitung im Callback findet synchron statt.\n           Deshalb sollte der Callback sehr schnell ausgeführt werden.\n"]
    pub fn EricRegistriereLogCallback(
        funktion: EricLogCallback,
        schreibeEricLogDatei: u32,
        benutzerdaten: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Diese API-Funktion erzeugt einen Rückgabepuffer und gibt\n        ein Handle darauf zurück.\n\n Die von dieser Funktion erzeugten Rückgabepuffer werden verwendet, um\n die Ausgaben von ERiC-Funktionen (z.B. EricBearbeiteVorgang())\n aufzunehmen. Dazu wird das Rückgabepuffer-Handle für den Schreibvorgang\n an die ausgebende Funktion übergeben.<br>\n Zum Auslesen des von den API-Funktionen beschriebenen Puffers wird das\n Rückgabepuffer-Handle an EricRueckgabepufferInhalt() übergeben.\n Ein einmal erzeugtes Rückgabepuffer-Handle kann für weitere nachfolgende\n Aufrufe von ERiC API-Funktionen wiederverwendet werden. Bei einer\n Wiederverwendung eines Handles werden frühere Inhalte überschrieben.\n Nach Verwendung muss jeder Rückgabepuffer mit\n EricRueckgabepufferFreigeben() freigegeben werden.\n Rückgabepuffer sind der Singlethreading-API bzw. einer ERiC-Instanz der\n Multithreading-API fest zugeordnet. Die Funktionen der ERiC API, die\n einen Rückgabepuffer entgegen nehmen, geben den Fehlercode\n ::ERIC_GLOBAL_PUFFER_UNGLEICHER_INSTANZ zurück, wenn der übergebene\n Rückgabepuffer\n      - mit der Singlethreading-API erzeugt worden ist und dann mit der\n        Multithreading-API verwendet wird\n      - mit der Multithreading-API erzeugt worden ist und dann mit der\n        Singlethreading-API verwendet wird\n      - mit einer ERiC-Instanz erzeugt worden ist und dann mit einer\n        anderen Instanz verwendet wird.\n\n\n @return\n         - ::EricRueckgabepufferHandle im Erfolgsfall.\n         - NULL im Fehlerfall.\n\n @see\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferInhalt()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferErzeugen() -> EricRueckgabepufferHandle;
}
extern "C" {
    #[doc = " @brief Der durch das @c handle bezeichnete Rückgabepuffer wird\n        freigegeben.\n\n Das Handle darf danach nicht weiter verwendet werden. Es wird daher\n empfohlen, Handle-Variablen nach der Freigabe explizit auf\n NULL zu setzen.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen().\n            angelegten Rückgabepuffer. Dieser Rückgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_UNGUELTIGER_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - ::ERIC_GLOBAL_UNKNOWN\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferInhalt()"]
    pub fn EricRueckgabepufferFreigeben(handle: EricRueckgabepufferHandle)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Der durch das @c handle bezeichnete Inhalt des Rückgabepuffers wird zurückgegeben.\n\n Der zurückgegebene Zeiger verweist auf ein Byte-Array, das alle in\n den Rückgabepuffer geschriebenen Bytes sowie eine abschließende\n NULL-Terminierung enthält. Dieses Array existiert so lange im Speicher,\n bis der Rückgabepuffer entweder (bei einer Wiederverwendung des Handles)\n erneut beschrieben oder der Puffer explizit freigegeben wird.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen().\n            angelegten Rückgabepuffer. Dieser Rückgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n         - Zeiger auf den NULL-terminierten Rückgabepufferinhalt, wenn ein gültiges Handle übergeben wird.\n         - NULL: Bei Übergabe des ungültigen Handles NULL.\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferLaenge()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferInhalt(
        handle: EricRueckgabepufferHandle,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Die Länge des Rückgabepufferinhalts wird zurückgegeben.\n\n Die zurückgegebene Zahl entspricht der Anzahl von Bytes, die von einer\n zuvor aufgerufenen ERiC API-Funktion in den Rückgabepuffer geschrieben\n wurden.\n Die NULL-Terminierung, die bei Aufruf von EricRueckgabepufferInhalt() an\n das zurückgegebene Byte-Array angefügt wird, wird bei dieser\n Längenangabe nicht berücksichtigt.\n\n @param[in] handle Handle auf einen mit EricRueckgabepufferErzeugen()\n            angelegten Rückgabepuffer. Dieser Rückgabepuffer darf nicht\n            bereits freigegeben worden sein.\n\n @return\n         - Anzahl der in den Rückgabepuffer geschriebenen Bytes, wenn ein gültiges Handle übergeben wird.\n         - 0: Bei Übergabe des ungültigen Handles NULL.\n\n @see\n         - EricRueckgabepufferErzeugen()\n         - EricRueckgabepufferInhalt()\n         - EricRueckgabepufferFreigeben()"]
    pub fn EricRueckgabepufferLaenge(handle: EricRueckgabepufferHandle) -> u32;
}
extern "C" {
    #[doc = " @brief Es werden Plattform-, Betriebssystem- und\n        ERiC-Informationen ausgegeben.\n\n Diese Funktion liefert Informationen über die\n verwendeten ERiC-Bibliotheken, ERiC-Druckvorlagen,\n die eingesetzte Plattform, den Arbeitsspeicher und\n das verwendete Betriebssystem.\n\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - weitere, siehe eric_fehlercodes.h\n\n @see\n      - EricVersion()"]
    pub fn EricSystemCheck() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Es wird eine Liste sämtlicher Produkt- und Dateiversionen\n        der verwendeten ERiC-Bibliotheken als XML-Daten zurückgegeben.\n\n Diese Funktion kann bei auftretenden Fehlern die\n Fehlersuche beschleunigen und Supportfälle unterstützen.\n\n @param[out] rueckgabeXmlPuffer Handle auf einen Rückgabepuffer, in den\n            zu allen ERiC-Bibliotheken die Produkt- und Dateiversionen\n            als XML-Daten nach XML Schema Definition Dokumentation\\API-Rueckgabe-Schemata\\EricVersion.xsd\n            geschrieben werden. Zur Erzeugung, Verwendung und Freigabe von Rückgabepuffern\n            siehe Dokumentation zu ::EricRueckgabepufferHandle.\n\n \\b Beispiel:\n \\code\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <EricVersion xmlns=\"http://www.elster.de/EricXML/1.0/EricVersion\">\n     <Bibliothek>\n       <Name>ericapi.dll</Name>\n       <Produktversion>99, 1, 2, 32767</Produktversion>\n       <Dateiversion>2008, 3, 5, 0</Dateiversion>\n     </Bibliothek>\n     <Bibliothek>\n       <Name>ericctrl.dll</Name>\n       <Produktversion>99, 1, 2, 32767</Produktversion>\n       <Dateiversion>2008, 3, 5, 0</Dateiversion>\n     </Bibliothek>\n     (...)\n </EricVersion>\n \\endcode\n\n @return\n  - ::ERIC_OK\n  - ::ERIC_GLOBAL_NULL_PARAMETER\n  - ::ERIC_GLOBAL_NICHT_GENUEGEND_ARBEITSSPEICHER\n  - weitere, siehe eric_fehlercodes.h\n\n @see\n      - EricSystemCheck()"]
    pub fn EricVersion(rueckgabeXmlPuffer: EricRueckgabepufferHandle) -> ::std::os::raw::c_int;
}
